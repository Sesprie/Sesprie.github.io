{"meta":{"title":"Sesprie","subtitle":null,"description":null,"author":"Sesprie","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-04-07T13:12:26.958Z","updated":"2018-04-07T12:55:58.683Z","comments":true,"path":"src/css/pace-theme-flash.css","permalink":"http://yoursite.com/src/css/pace-theme-flash.css","excerpt":"","text":"/* This is a compiled file, you should be editing the file in the templates directory */ .pace { -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .pace-inactive { display: none; } .pace .pace-progress { background: #e90f92; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 2px; } .pace .pace-progress-inner { display: block; position: absolute; right: 0px; width: 100px; height: 100%; box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92; opacity: 1.0; -webkit-transform: rotate(3deg) translate(0px, -4px); -moz-transform: rotate(3deg) translate(0px, -4px); -ms-transform: rotate(3deg) translate(0px, -4px); -o-transform: rotate(3deg) translate(0px, -4px); transform: rotate(3deg) translate(0px, -4px); } .pace .pace-activity { display: block; position: fixed; z-index: 2000; top: 15px; right: 15px; width: 14px; height: 14px; border: solid 2px transparent; border-top-color: #e90f92; border-left-color: #e90f92; border-radius: 10px; -webkit-animation: pace-spinner 400ms linear infinite; -moz-animation: pace-spinner 400ms linear infinite; -ms-animation: pace-spinner 400ms linear infinite; -o-animation: pace-spinner 400ms linear infinite; animation: pace-spinner 400ms linear infinite; } @-webkit-keyframes pace-spinner { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @-moz-keyframes pace-spinner { 0% { -moz-transform: rotate(0deg); transform: rotate(0deg); } 100% { -moz-transform: rotate(360deg); transform: rotate(360deg); } } @-o-keyframes pace-spinner { 0% { -o-transform: rotate(0deg); transform: rotate(0deg); } 100% { -o-transform: rotate(360deg); transform: rotate(360deg); } } @-ms-keyframes pace-spinner { 0% { -ms-transform: rotate(0deg); transform: rotate(0deg); } 100% { -ms-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes pace-spinner { 0% { transform: rotate(0deg); transform: rotate(0deg); } 100% { transform: rotate(360deg); transform: rotate(360deg); } }"},{"title":"","date":"2018-04-07T13:29:18.260Z","updated":"2018-04-07T13:29:18.177Z","comments":true,"path":"src/js/canvas-nest.min.js","permalink":"http://yoursite.com/src/js/canvas-nest.min.js","excerpt":"","text":"!function () { function o(w, v, i) { return w.getAttribute(v) || i } function j(i) { return document.getElementsByTagName(i) } function l() { var i = j(\"script\"), w = i.length, v = i[w - 1]; return {l: w, z: o(v, \"zIndex\", -1), o: o(v, \"opacity\", 0.5), c: o(v, \"color\", \"0,0,0\"), n: o(v, \"count\", 99)} } function k() { r = u.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, n = u.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight } function b() { e.clearRect(0, 0, r, n); var w = [f].concat(t); var x, v, A, B, z, y; t.forEach(function (i) { i.x += i.xa, i.y += i.ya, i.xa *= i.x > r || i.x < 0 ? -1 : 1, i.ya *= i.y > n || i.y < 0 ? -1 : 1, e.fillRect(i.x - 0.5, i.y - 0.5, 1, 1); for (v = 0; v < w.length; v++) { x = w[v]; if (i !== x && null !== x.x && null !== x.y) { B = i.x - x.x, z = i.y - x.y, y = B * B + z * z; y < x.max && (x === f && y >= x.max / 2 && (i.x -= 0.03 * B, i.y -= 0.03 * z), A = (x.max - y) / x.max, e.beginPath(), e.lineWidth = A / 2, e.strokeStyle = \"rgba(\" + s.c + \",\" + (A + 0.2) + \")\", e.moveTo(i.x, i.y), e.lineTo(x.x, x.y), e.stroke()) } } w.splice(w.indexOf(i), 1) }), m(b) } var u = document.createElement(\"canvas\"), s = l(), c = \"c_n\" + s.l, e = u.getContext(\"2d\"), r, n, m = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (i) { window.setTimeout(i, 1000 / 45) }, a = Math.random, f = {x: null, y: null, max: 20000}; u.id = c; u.style.cssText = \"position:fixed;top:0;left:0;z-index:\" + s.z + \";opacity:\" + s.o; j(\"body\")[0].appendChild(u); k(), window.onresize = k; window.onmousemove = function (i) { i = i || window.event, f.x = i.clientX, f.y = i.clientY }, window.onmouseout = function () { f.x = null, f.y = null }; for (var t = [], p = 0; s.n > p; p++) { var h = a() * r, g = a() * n, q = 2 * a() - 1, d = 2 * a() - 1; t.push({x: h, y: g, xa: q, ya: d, max: 6000}) } setTimeout(function () { b() }, 100) }();"},{"title":"","date":"2018-04-07T12:55:27.679Z","updated":"2018-04-07T12:55:27.565Z","comments":true,"path":"src/js/pace.min.js","permalink":"http://yoursite.com/src/js/pace.min.js","excerpt":"","text":"/*! pace 1.0.2 */ (function () { var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X = [].slice, Y = {}.hasOwnProperty, Z = function (a, b) { function c() { this.constructor = a } for (var d in b) Y.call(b, d) && (a[d] = b[d]); return c.prototype = b.prototype, a.prototype = new c, a.__super__ = b.prototype, a }, $ = [].indexOf || function (a) { for (var b = 0, c = this.length; c > b; b++) if (b in this && this[b] === a) return b; return -1 }; for (u = { catchupTime: 100, initialRate: .03, minTime: 250, ghostTime: 100, maxProgressPerFrame: 20, easeFactor: 1.25, startOnPageLoad: !0, restartOnPushState: !0, restartOnRequestAfter: 500, target: \"body\", elements: {checkInterval: 100, selectors: [\"body\"]}, eventLag: {minSamples: 10, sampleCount: 3, lagThreshold: 3}, ajax: {trackMethods: [\"GET\"], trackWebSockets: !0, ignoreURLs: []} }, C = function () { var a; return null != (a = \"undefined\" != typeof performance && null !== performance && \"function\" == typeof performance.now ? performance.now() : void 0) ? a : +new Date }, E = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame, null == E && (E = function (a) { return setTimeout(a, 50) }, t = function (a) { return clearTimeout(a) }), G = function (a) { var b, c; return b = C(), (c = function () { var d; return d = C() - b, d >= 33 ? (b = C(), a(d, function () { return E(c) })) : setTimeout(c, 33 - d) })() }, F = function () { var a, b, c; return c = arguments[0], b = arguments[1], a = 3 e; e++) d = a[e], c += Math.abs(d), b++; return c / b }, x = function (a, b) { var c, d, e; if (null == a && (a = \"options\"), null == b && (b = !0), e = document.querySelector(\"[data-pace-\" + a + \"]\")) { if (c = e.getAttribute(\"data-pace-\" + a), !b) return c; try { return JSON.parse(c) } catch (f) { return d = f, \"undefined\" != typeof console && null !== console ? console.error(\"Error parsing inline pace options\", d) : void 0 } } }, g = function () { function a() { } return a.prototype.on = function (a, b, c, d) { var e; return null == d && (d = !1), null == this.bindings && (this.bindings = {}), null == (e = this.bindings)[a] && (e[a] = []), this.bindings[a].push({ handler: b, ctx: c, once: d }) }, a.prototype.once = function (a, b, c) { return this.on(a, b, c, !0) }, a.prototype.off = function (a, b) { var c, d, e; if (null != (null != (d = this.bindings) ? d[a] : void 0)) { if (null == b) return delete this.bindings[a]; for (c = 0, e = []; c < this.bindings[a].length;) e.push(this.bindings[a][c].handler === b ? this.bindings[a].splice(c, 1) : c++); return e } }, a.prototype.trigger = function () { var a, b, c, d, e, f, g, h, i; if (c = arguments[0], a = 2 e; e++) b = g[e], a.children[0].style[b] = d; return (!this.lastRenderedProgress || this.lastRenderedProgress | 0 !== this.progress | 0) && (a.children[0].setAttribute(\"data-progress-text\", \"\" + (0 | this.progress) + \"%\"), this.progress >= 100 ? c = \"99\" : (c = this.progress < 10 ? \"0\" : \"\", c += 0 | this.progress), a.children[0].setAttribute(\"data-progress\", \"\" + c)), this.lastRenderedProgress = this.progress }, a.prototype.done = function () { return this.progress >= 100 }, a }(), h = function () { function a() { this.bindings = {} } return a.prototype.trigger = function (a, b) { var c, d, e, f, g; if (null != this.bindings[a]) { for (f = this.bindings[a], g = [], d = 0, e = f.length; e > d; d++) c = f[d], g.push(c.call(this, b)); return g } }, a.prototype.on = function (a, b) { var c; return null == (c = this.bindings)[a] && (c[a] = []), this.bindings[a].push(b) }, a }(), P = window.XMLHttpRequest, O = window.XDomainRequest, N = window.WebSocket, w = function (a, b) { var c, d, e; e = []; for (d in b.prototype) try { e.push(null == a[d] && \"function\" != typeof b[d] ? \"function\" == typeof Object.defineProperty ? Object.defineProperty(a, d, { get: function () { return b.prototype[d] }, configurable: !0, enumerable: !0 }) : a[d] = b.prototype[d] : void 0) } catch (f) { c = f } return e }, A = [], j.ignore = function () { var a, b, c; return b = arguments[0], a = 2 c; c++) if (b = e[c], \"string\" == typeof b) { if (-1 !== a.indexOf(b)) return !0 } else if (b.test(a)) return !0; return !1 }, y().on(\"request\", function (b) { var c, d, e, f, g; return f = b.type, e = b.request, g = b.url, I(g) ? void 0 : j.running || D.restartOnRequestAfter === !1 && \"force\" !== J(f) ? void 0 : (d = arguments, c = D.restartOnRequestAfter || 0, \"boolean\" == typeof c && (c = 0), setTimeout(function () { var b, c, g, h, i, k; if (b = \"socket\" === f ? e.readyState < 2 : 0 < (h = e.readyState) && 4 > h) { for (j.restart(), i = j.sources, k = [], c = 0, g = i.length; g > c; c++) { if (K = i[c], K instanceof a) { K.watch.apply(K, d); break } k.push(void 0) } return k } }, c)) }), a = function () { function a() { var a = this; this.elements = [], y().on(\"request\", function () { return a.watch.apply(a, arguments) }) } return a.prototype.watch = function (a) { var b, c, d, e; return d = a.type, b = a.request, e = a.url, I(e) ? void 0 : (c = \"socket\" === d ? new n(b) : new o(b), this.elements.push(c)) }, a }(), o = function () { function a(a) { var b, c, d, e, f, g, h = this; if (this.progress = 0, null != window.ProgressEvent) for (c = null, a.addEventListener(\"progress\", function (a) { return h.progress = a.lengthComputable ? 100 * a.loaded / a.total : h.progress + (100 - h.progress) / 2 }, !1), g = [\"load\", \"abort\", \"timeout\", \"error\"], d = 0, e = g.length; e > d; d++) b = g[d], a.addEventListener(b, function () { return h.progress = 100 }, !1); else f = a.onreadystatechange, a.onreadystatechange = function () { var b; return 0 === (b = a.readyState) || 4 === b ? h.progress = 100 : 3 === a.readyState && (h.progress = 50), \"function\" == typeof f ? f.apply(null, arguments) : void 0 } } return a }(), n = function () { function a(a) { var b, c, d, e, f = this; for (this.progress = 0, e = [\"error\", \"open\"], c = 0, d = e.length; d > c; c++) b = e[c], a.addEventListener(b, function () { return f.progress = 100 }, !1) } return a }(), d = function () { function a(a) { var b, c, d, f; for (null == a && (a = {}), this.elements = [], null == a.selectors && (a.selectors = []), f = a.selectors, c = 0, d = f.length; d > c; c++) b = f[c], this.elements.push(new e(b)) } return a }(), e = function () { function a(a) { this.selector = a, this.progress = 0, this.check() } return a.prototype.check = function () { var a = this; return document.querySelector(this.selector) ? this.done() : setTimeout(function () { return a.check() }, D.elements.checkInterval) }, a.prototype.done = function () { return this.progress = 100 }, a }(), c = function () { function a() { var a, b, c = this; this.progress = null != (b = this.states[document.readyState]) ? b : 100, a = document.onreadystatechange, document.onreadystatechange = function () { return null != c.states[document.readyState] && (c.progress = c.states[document.readyState]), \"function\" == typeof a ? a.apply(null, arguments) : void 0 } } return a.prototype.states = {loading: 0, interactive: 50, complete: 100}, a }(), f = function () { function a() { var a, b, c, d, e, f = this; this.progress = 0, a = 0, e = [], d = 0, c = C(), b = setInterval(function () { var g; return g = C() - c - 50, c = C(), e.push(g), e.length > D.eventLag.sampleCount && e.shift(), a = q(e), ++d >= D.eventLag.minSamples && a < D.eventLag.lagThreshold ? (f.progress = 100, clearInterval(b)) : f.progress = 100 * (3 / (a + 3)) }, 50) } return a }(), m = function () { function a(a) { this.source = a, this.last = this.sinceLastUpdate = 0, this.rate = D.initialRate, this.catchup = 0, this.progress = this.lastProgress = 0, null != this.source && (this.progress = F(this.source, \"progress\")) } return a.prototype.tick = function (a, b) { var c; return null == b && (b = F(this.source, \"progress\")), b >= 100 && (this.done = !0), b === this.last ? this.sinceLastUpdate += a : (this.sinceLastUpdate && (this.rate = (b - this.last) / this.sinceLastUpdate), this.catchup = (b - this.progress) / D.catchupTime, this.sinceLastUpdate = 0, this.last = b), b > this.progress && (this.progress += this.catchup * a), c = 1 - Math.pow(this.progress / 100, D.easeFactor), this.progress += c * this.rate * a, this.progress = Math.min(this.lastProgress + D.maxProgressPerFrame, this.progress), this.progress = Math.max(0, this.progress), this.progress = Math.min(100, this.progress), this.lastProgress = this.progress, this.progress }, a }(), L = null, H = null, r = null, M = null, p = null, s = null, j.running = !1, z = function () { return D.restartOnPushState ? j.restart() : void 0 }, null != window.history.pushState && (T = window.history.pushState, window.history.pushState = function () { return z(), T.apply(window.history, arguments) }), null != window.history.replaceState && (W = window.history.replaceState, window.history.replaceState = function () { return z(), W.apply(window.history, arguments) }), l = {ajax: a, elements: d, document: c, eventLag: f}, (B = function () { var a, c, d, e, f, g, h, i; for (j.sources = L = [], g = [\"ajax\", \"elements\", \"document\", \"eventLag\"], c = 0, e = g.length; e > c; c++) a = g[c], D[a] !== !1 && L.push(new l[a](D[a])); for (i = null != (h = D.extraSources) ? h : [], d = 0, f = i.length; f > d; d++) K = i[d], L.push(new K(D)); return j.bar = r = new b, H = [], M = new m })(), j.stop = function () { return j.trigger(\"stop\"), j.running = !1, r.destroy(), s = !0, null != p && (\"function\" == typeof t && t(p), p = null), B() }, j.restart = function () { return j.trigger(\"restart\"), j.stop(), j.start() }, j.go = function () { var a; return j.running = !0, r.render(), a = C(), s = !1, p = G(function (b, c) { var d, e, f, g, h, i, k, l, n, o, p, q, t, u, v, w; for (l = 100 - r.progress, e = p = 0, f = !0, i = q = 0, u = L.length; u > q; i = ++q) for (K = L[i], o = null != H[i] ? H[i] : H[i] = [], h = null != (w = K.elements) ? w : [K], k = t = 0, v = h.length; v > t; k = ++t) g = h[k], n = null != o[k] ? o[k] : o[k] = new m(g), f &= n.done, n.done || (e++, p += n.tick(b)); return d = p / e, r.update(M.tick(b, d)), r.done() || f || s ? (r.update(100), j.trigger(\"done\"), setTimeout(function () { return r.finish(), j.running = !1, j.trigger(\"hide\") }, Math.max(D.ghostTime, Math.max(D.minTime - (C() - a), 0)))) : c() }) }, j.start = function (a) { v(D, a), j.running = !0; try { r.render() } catch (b) { i = b } return document.querySelector(\".pace\") ? (j.trigger(\"start\"), j.go()) : setTimeout(j.start, 50) }, \"function\" == typeof define && define.amd ? define([\"pace\"], function () { return j }) : \"object\" == typeof exports ? module.exports = j : D.startOnPageLoad && j.start() }).call(this);"}],"posts":[{"title":"记录一次填npm安装依赖坑的经历","slug":"articles/17","date":"2018-04-25T11:17:17.403Z","updated":"2018-04-26T06:24:29.805Z","comments":true,"path":"articles/17.html","link":"","permalink":"http://yoursite.com/articles/17.html","excerpt":"","text":"闲来无事，想改改hexo博客的标签云样式，找到了一篇博客，跟着节奏走着走着，不小心踩了好多坑，好歹我坚强，几次google 后，我爬起来了。。。 错误一： 1234&gt;。。。&gt;gyp ERR! stack Error: Can&apos;t find Python executable &quot;python&quot;, you can set the PYTHON env variable.&gt;。。。&gt; 提示缺少python，wtf，明明安装了python 并配置了环境变量，居然提示找不到， 答案在这里 If you haven’t got python installed along with all the node-gyp dependecies, simply execute: 12&gt;npm install --global --production windows-build-tools&gt; and then to install the package: 12&gt;npm install --global node-gyp&gt; once installed, you will have all the node-gyp dependencies downloaded, but you still need the environment variable. Validate Python is indeed found in the correct folder: 12&gt;C:\\Users\\ben\\.windows-build-tools\\python27\\python.exe &gt; Note - it uses python 2.7 not 3.x as it is not supported If it doesn’t moan, go ahead and create your (user) environment variable: 12&gt;setx PYTHON &quot;%USERPROFILE%\\.windows-build-tools\\python27\\python.exe&quot;&gt; restart cmd, and verify the variable exists via set PYTHON which should return the variable Lastly re-apply npm install &lt;module&gt; 错误二（可选）：我在安装canvas 的时候， 提示缺少GTK 详细答案在这里 下面选择Chocolatey 安装依赖 需要先以管理员身份打开cmd，输入 1@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; 其他的安装Chocolatey的方式，看这里 All the dependencies can be installed with Chocolatey, the package manager for Windows. choco install -y python2 gtk-runtime microsoft-build-tools libjpeg-turbo (may require sudo/Administrator and reboot). You will need the cairo library which is bundled in GTK. Download the GTK 2 bundle for Win32or Win64. Unzip the contents in C:\\GTK. Run npm install canvas or yarn add node-canvas with command line from your project folder. 历经周折，安装好了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo博客,删除已提交到github pages上的文件或文件夹","slug":"articles/14","date":"2018-04-25T08:48:13.219Z","updated":"2018-04-25T08:59:11.518Z","comments":true,"path":"articles/14.html","link":"","permalink":"http://yoursite.com/articles/14.html","excerpt":"","text":"找到本地的hexo目录，命令行下进入.deploy_git目录，假设这里需要删除tags文件夹， 123git rm -r --cached tags # 删除tags文件夹git commit -m '删除了tags文件夹'# 为此次改变添加注释git push # 提交更改 更多命令：git --help 以查看帮助","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"用javascript生成由大小写字母组成指定数量的字符串","slug":"articles/11","date":"2018-04-24T06:22:42.189Z","updated":"2018-04-25T08:07:59.573Z","comments":true,"path":"articles/11.html","link":"","permalink":"http://yoursite.com/articles/11.html","excerpt":"","text":"12345678910111213141516171819202122232425262728//Math.random()可以产生(0,1)之间的随机数，不包括0和1//Math.floor()向下取整，例如对61.9取整的结果为61，对-6.9取取整的结果为-7，所有需要将字符串的长度+1再与Math.random()相乘，否则取不到最后一个字符function createString(count)&#123; var text = \"\"; var string_tmp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123546789\"; for(var i = 0; i &lt; count; i++)&#123; text += string_tmp.charAt(Math.floor(Math.random() * (string_tmp.length+1))); &#125; return text;&#125;//输出10个长度为11的字符串for (var x = 0; x &lt; 10; x++)&#123; console.log(createString(11));&#125;//长度为11时，可能的输出结果的数量var y = 1;for (var i = 0; i &lt; 11; i++)&#123; y = y*62;&#125;console.log(\"11位字符串的数量: \" + y)","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"code::blocks编译器环境的配置","slug":"articles/5","date":"2018-04-23T03:12:56.017Z","updated":"2018-04-23T03:15:24.918Z","comments":true,"path":"articles/5.html","link":"","permalink":"http://yoursite.com/articles/5.html","excerpt":"","text":"方法一：简单省事到此处下载免安装带编译器版本codeblocks-16.01mingw-nosetup.zip，解压运行即可。 方法二：使用tdm-gcc编译器NOTE：如果是先安装的tdm-gcc，再安装的code::blocks，那么，打开时，直接保持默认选项即可直接使用。到此处下载符合你需求的tdm-gcc版本，安装到默认位置即可。到此处下载任意版本code::blocks。打开code::blocks，提示信息中选择默认选项即可，菜单栏中找到Setting-&gt;compiler-&gt;Toolchain executables，点击Auto-detect自动检测(如果你下载的是带编译器版本的，会默认使用其目录下的mingw，这样的话，后面的步骤忽略直接使用即可)，如果不是带编译器版本的，一般会检测到你的tdm-gcc的安装目录，点击Set as default(如果可点)，点击OK即可。如果不能编译文件，则需要将C compiler、C++ compiler等，改成与图片中相符合的文件名称。","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"探究python切片原理，动手实现list切片","slug":"articles/3","date":"2018-04-23T03:06:47.883Z","updated":"2018-04-24T06:37:32.933Z","comments":true,"path":"articles/3.html","link":"","permalink":"http://yoursite.com/articles/3.html","excerpt":"","text":"还能不动声色饮茶，踏碎这一场，盛世烟花 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143# -*- coding:utf-8 -*-# 探究切片的原理# 该代码的功能：用函数实现列表的切片，def between(beg, end, mid): return end &gt; mid &gt;= beg or end &lt; mid &lt;= begdef get_slice(a, beg, end, delta = 1): if delta == 0: raise ValueError(\"slice step cannot be 0\") # 将负数转化成正数下标表示 if beg &lt; 0: beg += len(a) if end &lt; 0: end += len(a) # 如果转化完成之后依然不在合法范围内，则返回空列表 if beg &lt; 0 and end &lt; 0 or beg &gt;= len(a) and end &gt;= len(a): print(\"begin都小于0 或 长度都越界\") return [] # 如果end-beg 与 delta 的方向不同，返回空列表 if(end - beg) * delta &lt;= 0: print(\"end - beg 与 delta 的方向不相同\") return [] # 对越界的部分裁剪，即beg或end超过的a的长度则返回a最后一个元素的下标即len(a) - 1 beg = max(0, min(beg, len(a) - 1)) end = max(-1, min(end, len(a))) ans = [] i = beg print(\"beg:%d, end:%d, delta:%d\"%(beg, end, delta)) while between(beg, end, i): ans.append(i) i += delta return ansdef test_getslice(): import random a = list(range(10)) for i in range(10): beg = random.randint(-15, 15) end = random.randint(-15, 15) delta = 0 while delta == 0: delta = random.randint(-15, 15) print(\"a:\", a) print(\"beg:%d,end:%d,delta:%d\"%(beg, end, delta)) ans = get_slice(a, beg, end, delta) print(\"get_slice(a, beg, end, delta):\", ans) print(\"a[beg:end:delta]:\", a[beg:end:delta]) print(len(ans) == len(a[beg:end:delta])) print(\"\")test_getslice()\"\"\"def between(beg, end, mid): # 判断mid是否位于begin和end之间 return end &gt; mid &gt;= beg or end &lt; mid &lt;= begdef get_slice(a, beg, end, delta=1): # 数组切片get方式 if delta == 0: raise ValueError(\"slice step cannot be 0\") # 将负数下标转化一下 if beg &lt; 0: beg += len(a) if end &lt; 0: end += len(a) # 如果转化完成之后依然不在合法范围内，则返回空列表 if beg &lt; 0 and end &lt; 0 or beg &gt;= len(a) and end &gt;= len(a): return [] # 如果方向不同，则返回空列表 if (end - beg) * delta &lt;= 0: return [] # 将越界的部分进行裁剪 beg = max(0, min(beg, len(a) - 1)) end = max(-1, min(end, len(a))) ans = [] i = beg while between(beg, end, i): ans.append(a[i]) i += delta return ansdef set_slice(a, li, beg, end, delta=1): if delta == 0: raise ValueError(\"slice step cannot be 0\") if delta == 1: # 如果delta==1，那么li的长度可以随意 if beg &lt; 0: beg += len(a) if end &lt; 0: end += len(a) beg = max(0, min(beg, len(a) - 1)) end = max(-1, min(end, len(a))) for i in range(beg, end): del a[beg] for i in reversed(li): a.insert(beg, i) else: # delta!=1,相当于替换 if len(get_slice(a, beg, end, delta)) != len(li): raise ValueError(\"array don't match\") if len(li) == 0: return if beg &lt; 0: beg += len(a) if end &lt; 0: end += len(a) beg = max(0, min(beg, len(a) - 1)) # 用li中的全部元素逐一替换 for ind, value in enumerate(li): a[ind * delta + beg] = valuedef test_getSlice(): a = list(range(10)) import random for i in range(10): beg = random.randint(-15, 15) end = random.randint(-15, 15) delta = 0 while delta == 0: delta = random.randint(-15, 15) print(len(get_slice(a, beg, end, delta)) == len(a[beg:end:delta]), beg, end, delta)def test_setSlice(): import random for i in range(10): a = list(range(10)) beg = random.randint(-15, 15) end = random.randint(-15, 15) delta = 0 while delta == 0: delta = random.randint(-5, 5) sz = len(a[beg:end:delta]) if delta == 1: sz = random.randint(0, 4) li = [random.randint(0, 100) for i in range(sz)] set_slice(a, li, beg, end, delta) mine = a a = list(range(10)) a[beg:end:delta] = li print(a == mine)test_setSlice()\"\"\"","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"windows命令行常用命令","slug":"articles/2","date":"2018-04-23T03:00:55.984Z","updated":"2018-04-24T06:38:45.588Z","comments":true,"path":"articles/2.html","link":"","permalink":"http://yoursite.com/articles/2.html","excerpt":"","text":"1.taskkill /f /im explorer.exe &amp; start explorer.exe 关闭资源管理器并重新启动","categories":[],"tags":[{"name":"Dos","slug":"Dos","permalink":"http://yoursite.com/tags/Dos/"}]},{"title":"功能强大的文件搜索软件 - Everything","slug":"articles/1","date":"2018-04-22T11:16:27.823Z","updated":"2018-04-25T08:07:23.959Z","comments":true,"path":"articles/1.html","link":"","permalink":"http://yoursite.com/articles/1.html","excerpt":"","text":"Everything(官网|中文主页)是速度最快的文件名搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具、Total Commander的搜索、Google 桌面搜索或百度硬盘搜索，如果正在使用或放弃了Locate32，都值得推荐这款体积小巧、免安装、免费、速度极快（比Locate32更快）的文件搜索工具Everything！ 设置快捷键呼出、关闭：打开Everything， 按下Ctrl+P切换到快捷键选项，输入你想设置的快捷键，就可以全局呼出关闭","categories":[],"tags":[{"name":"Windows软件","slug":"Windows软件","permalink":"http://yoursite.com/tags/Windows软件/"}]},{"title":"dos下导出当前目录所有文件的名称到文件","slug":"windows/dos-02","date":"2018-04-21T23:56:17.957Z","updated":"2018-04-25T08:07:09.264Z","comments":true,"path":"windows/dos-02.html","link":"","permalink":"http://yoursite.com/windows/dos-02.html","excerpt":"","text":"使用重定向的方式: dos下进入要导出文件名的目录： 1dir &gt; filename.txt 如果不需要时间、大小等信息，添加/b即可： 1dir /b &gt; filename.txt 此处&gt;的作用相当于重定向，会将dir的输出的结果写入文件 如果希望将子目录中的文件和文件夹列表也全部列出来使用\\s 1dir /s /b &gt; filename.txt 生成的文本拷贝到excel进行相应的处理。 还可以使用bat 文件直接处理 1，打开一个记事本文档，然后复制下列内容到文档中。 123@echo offdir /b *.* &gt; filename.txtexit 2、将上述内容复制到要提取文件名的文件夹，然后将该文件改名为X.bat(X可为任意名称)，然后双击运行。","categories":[],"tags":[{"name":"Dos","slug":"Dos","permalink":"http://yoursite.com/tags/Dos/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}]},{"title":"windows中的常用快捷键以及dos命令","slug":"windows/dos-01","date":"2018-04-21T09:12:08.299Z","updated":"2018-04-25T08:07:09.262Z","comments":true,"path":"windows/dos-01.html","link":"","permalink":"http://yoursite.com/windows/dos-01.html","excerpt":"","text":"1234567891011121314151617dos命令:用命令打开电脑属性：sysdm.cpl打开网络连接：ncpa.cplshutdown的相关使用(命令行输入)：shutdown /?打开休眠功能：powercfg -hibernate on复制文件夹到其他目录：xcopy c:\\directory d:\\directory /e(directory名称要一样，如果不加上该目录名，那么到d盘就会一片混乱)打开组策略：gpedit.msc打开注册表：regedit快捷键：win+L：锁定计算机win+E ：打开资源管理器win + Break：打开系统属性F2：对当前选定的文件重命名win+R：打开运行对话框创建带点的文件夹：在cmd中进入欲创建文件夹的目录，输入md .directory快速打开固定在任务栏的应用：Win+应用所在的位置，可快捷打开","categories":[],"tags":[{"name":"Dos","slug":"Dos","permalink":"http://yoursite.com/tags/Dos/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}]},{"title":"docker在ubuntu中的安装","slug":"docker/docker-01","date":"2018-04-21T09:05:26.058Z","updated":"2018-04-25T08:07:39.707Z","comments":true,"path":"docker/docker-01.html","link":"","permalink":"http://yoursite.com/docker/docker-01.html","excerpt":"","text":"详细步骤访问这里，选择对应系统的版本 这里安装的是docker-ce（社区版）版本的 这里只使用简单的安装脚本 12curl -fsSL get.docker.com -o get-docker.sh sudo sh get-docker.sh 安装之后，输入docker version 会提示docker服务没有运行 cd /var/run/发现没有docker的进程 执行service docker start就可以启动docker进程 然后执行sudo docker run ubuntu echo &quot;Hello, World&quot;就可以用docker输出Hello,World","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"人体时钟","slug":"web/web-01","date":"2018-04-17T12:59:29.414Z","updated":"2018-04-24T06:39:34.373Z","comments":true,"path":"web/web-01.html","link":"","permalink":"http://yoursite.com/web/web-01.html","excerpt":"","text":"123456789101112&lt;html&gt;&lt;div id=\"myTime\"&gt; &lt;object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" codebase=\"http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0\" width=\"200\" height=\"80\" id=\"honehoneclock\" align=\"middle\"&gt; &lt;param name=\"allowScriptAccess\" value=\"always\"&gt; &lt;param name=\"movie\" value=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.swf\"&gt; &lt;param name=\"quality\" value=\"high\"&gt; &lt;param name=\"bgcolor\" value=\"#ffffff\"&gt; &lt;param name=\"wmode\" value=\"transparent\"&gt; &lt;embed wmode=\"transparent\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.swf\" quality=\"high\" bgcolor=\"#ffffff\" width=\"200\" height=\"80\" name=\"honehoneclock\" align=\"middle\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\"&gt; &lt;/object&gt; &lt;/div&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"按字节编址与按字编址","slug":"articles/12","date":"2018-04-17T12:12:12.267Z","updated":"2018-04-24T06:42:58.159Z","comments":true,"path":"articles/12.html","link":"","permalink":"http://yoursite.com/articles/12.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576我们先从一道简单的问题说起！ 设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小? 如果按字节编址，则 1MB = 2^20B （ps：1MB=1024kb，1kb=1024btye，1024是2的10次方） 1字节=1B=8bit 2^20B/1B = 2^20 地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为2^20=1M（ps：求出该存储器最多可容纳多少字节，从0到最多可容纳的字节数就是地址范围） 如果按字编址，则 1MB=2^20B 1字=32bit=4B（ps：字长是32位，就是指1字=32bit，该信息只有在按字编址时才有用。这里的字长说的是存储字长） 2^20B/4B = 2^18 地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是2^18以上题目注意几点：1.区分寻址空间与寻址范围两个不同的概念，寻址范围仅仅是一个数字范围，不带有单位而寻址范围的大小很明显是一个数，指寻址区间的大小 而寻址空间指能够寻址最大容量，单位一般用MB、B来表示；本题中寻址范围为0~(2^20)-1,寻址空间为1MB。2.按字节寻址，指的是存储空间的最小编址单位是字节，按字编址，是指存储空间的最小编址单位是字，以上题为例，总的存储器容量是一定的，按字编址和按字节编址所需要的编码数量是不同的，按字编址由于编址单位比较大（1字=32bit=4B），从而编码较少，而按字节编址由于编码单位较小（1字节=1B=8bit），从而编码较多。3.区别M和MB。 M为数量单位。1024=1K，1024K=1M MB指容量大小。1024B=1KB，1024KB=1MB.某机字长为32位,存储容量为64MB,若按字节编址.它的寻址范围是多少?问题：某机字长为32位,存储容量为64MB,若按字节编址.它的寻址范围是多少?问题：1、某计算机字长为32位,其存储容量为16MB,若按双字编址,它的寻址范围是多少?2、某机字长为32位,存储容量为64MB,若按字节编址.它的寻址范围是多少?解答：我的方法是全部换算成1位2进制的基本单元来算。先计算总容量，如第一题中是16mb中，一B为8位，也就是8个一位基本单元组成，16M=2^24位=2^24个一位基本单元。所以总的基本单元是2^24*8。一个字长是n位，就是说一个字是由n个一位基本单元组成。按照字来编址就是说由一个字所包含的一位基本单元的个数作为一个地址单元，它对应一个地址。同理，双字编址就是两个字所包含的的基本单元数作为一个地址单元。由于一个字节（1B）永远是8位，所以按字节编址永远是8个一位基本单元作为一个地址单元。寻址范围就是说总共有多少个这样的地址。第一题中一个字长是32位，对于按字编址来说一个地址单元有32个基本单元，按双字编址则是一个地址单元有64个，按字节是8个，总容量是2^24*8个。所以按字编址的地址数是2^24*8/32个，按双字是2^24*8/64个，按字节是2^24*8/8个。因此，第一题答案是2^21=2M。同理，第二题答案是2^26*8/8=2^26=64M。","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/计算机基础/"}]},{"title":"抓取某一条微博的评论信息[移动端]","slug":"wireshark/wireshark-02","date":"2018-04-12T03:35:08.880Z","updated":"2018-04-24T06:37:28.325Z","comments":true,"path":"wireshark/wireshark-02.html","link":"","permalink":"http://yoursite.com/wireshark/wireshark-02.html","excerpt":"","text":"1.打开任意一条微博的页面（手机端m.weibo.cn)，这里按下F12打开开发者工具（这里使用的是Firefox），在页面内下拉时会产生请求，请求链接有规律 2.这里的请求链接中的id跟网页的那条微博id一致 3.对任意一条请求进行分析，请求返回的内容为json格式的数据， 4.只对该条微博的评论进行抓取 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-import requestsimport reimport timeheaders = &#123;'Host': 'm.weibo.cn', 'Referer': 'https://m.weibo.cn/status/4227588807322638', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:58.0) Gecko/20100101 Firefox/58.0'&#125;# 会以当前微博id命名file_path = 'C:/Users/xxx/Desktop/weibo_' + headers['Referer'].split(\"/\")[-1] + '.txt'def crawl(): url = 'https://m.weibo.cn/api/comments/show?id=4227588807322638&amp;page=' page = 0 while True: html = requests.get(url + str(page), headers=headers) print(url + str(page)) page += 1 json_response = html.json() ok = json_response['ok'] # 获取返回状态，0表示获取失败或已没有数据，1表示获取成功 if ok == 0: # 如果请求失败，就break break data = json_response['data']['data'] for i in range(0, len(data)): # ''.join()表示将列表组合成字符串，re.findall()在这里会返回一个列表，里面包含着一个个的汉字 text_chinese = ''.join(re.findall('[\\u4e00-\\u9fa5]', data[i]['text'])) # '[\\u4e00-\\u9fa5]'表示取汉字，取出所有的汉字，标点符号什么的全部扔掉 print(text_chinese) # 以追加方式打开，将数据写入文件 with open(file_path, 'a', encoding='utf-8') as fp: fp.write(text_chinese+'\\n') time.sleep(1)if __name__ == '__main__': crawl() 抓取结果：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/抓包/"}]},{"title":"用Python爬取Instagram上某用户的图片(动态页面)(一)","slug":"python/python-04","date":"2018-04-11T01:27:03.353Z","updated":"2018-04-24T06:37:21.367Z","comments":true,"path":"python/python-04.html","link":"","permalink":"http://yoursite.com/python/python-04.html","excerpt":"","text":"1.打开任意一位Instagram用户的首页，这里以https://www.instagram.com/melissamale/为例，对任意一张图片进行检查，没有发现图片链接， 2.打开图片所在页面，对图片进行检查，发现两个div都指向了该图片，在其中一个div中找到了图片的地址， 3.复制找到的图片地址，回到用户首页，查看页面的源代码，查找链接找到了一个display_url节点， 4.搜索display_url节点，找到了十来个，对应的地址打开后均是图片，并且这些都包含在js脚本中 5.其中的脚本很像json数据，校验之后，确实是json数据，这样就可以利用python中的json库提取相应的节点 6.下面的Python代码将对首页的html源码中的图片链接数据进行提取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding: utf-8 -*-import requestsimport jsonfrom lxml import etreeimport clickimport os# =========================需要自定义的参数========================================# 在网站不变动的情况下，只需要更改此处用户名就可以获取首页的12张图片BASE_URL = \"https://www.instagram.com/melissamale/\"# 存储图片的文件夹的路径path_dir = \"C:/Users/xxx/Desktop/intagrsm_img\"# 添加代理，指定本地代理端口proxies = &#123; 'https': 'https://127.0.0.1:38251'&#125;# =========================需要自定义的参数========================================headers = &#123;\"Referer\": \"https://www.instagram.com/urnotchrislee/?hl=zh-cn\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36\"&#125;# 存储首页图片的真实链接的列表img_list = []# 下载指定链接的文件到指定目录，path是文件夹的全路径，file_url必须是以后缀名结尾的文件def download_file(file_url, path): # 从链接中取出文件的名称 filename = file_url.split(\"/\")[-1] response = requests.get(file_url, headers=headers, proxies=proxies) fb = open(path + '/' + filename, 'wb') fb.write(response.content) fb.close()def crawl(): click.echo('start') # 判断指定存储图片的文件夹是否存在，不存在则创建 if not os.path.exists(path_dir): os.makedirs(path_dir) try: # 发送请求，获取源码 res = requests.get(BASE_URL, headers=headers, proxies=proxies) html = etree.HTML(res.content.decode()) # 提取所有的script标签中的文本 all_script_tags = html.xpath('//body/script[@type=\"text/javascript\"]/text()') for script_tag in all_script_tags: # strip()默认过滤掉空格 if script_tag.strip().startswith(''): data = script_tag.replace('window._sharedData = ', '')[ :-1] # 提取json数据，必须保证&#123;&#125;外面没有其余数据，尾部的[:-1]去除最后一个字符，这里json数据尾部有个; json_data = json.loads(data, encoding='utf-8') # 将str格式化成json格式 # 下面的节点可能会随着网站的更新而改变 edges = json_data['entry_data']['ProfilePage'][0]['graphql']['user']['edge_owner_to_timeline_media'][ 'edges'] for edge in edges: img_url = edge['node']['display_url'] # 图片的真实链接 img_list.append(img_url) print(edge['node']['display_url']) download_file(img_url, path_dir) # 下载图片 break click.echo('success') except Exception as e: raise eif __name__ == '__main__': crawl() 以上内容参照下面的文章一本正经的胡说八道着： Python之Instagram图片爬虫（一） 【python爬虫】动态加载页面的解决办法（以ins为例） 纯属小白，大佬轻喷。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/抓包/"}]},{"title":"写给自学者的入门指南","slug":"other/1","date":"2018-04-10T05:35:02.549Z","updated":"2018-04-22T13:35:01.979Z","comments":true,"path":"other/1.html","link":"","permalink":"http://yoursite.com/other/1.html","excerpt":"","text":"​ 在IT工程师和培训机构多如牛毛的时代，拜师学艺并不难。但自学编程对于毫无基础的同学来说却可能是个问题，相信有过类似经历的朋友都有一把辛酸泪和一肚不吐不快的体会。让我们从一个故事说起… 故事 某君在一个普通大学读着自己不喜欢的专业，以打游戏、刷段子和睡觉度日，突然有一天想学点什么。学编程好像挺酷，而且听说IT行业充满了机会，没准一不小心就和大佬一起“改变世界”了。 那么第一个问题来了，他该选择什么语言？ 是世界上最好的语言PHP？还是语言之母的C？幸好还知道个编程语言排行榜，找到一看、几十种不带重样，这要逼死天秤座的小朋友。选PHP吧？上非诚勿扰都要被灭灯，而且就只能做个网页。万般纠结之后我们选C吧，听起来既高级又底层，说不准还能考个计算机二级。 接下来得干正事儿了。在这个便捷的网络时代，自学可选择的方式非常丰富。除了在网络上收集资料、阅读干货外，某君还向一些前辈咨询了自学的方法。 网络上流传的编程学习方式有： 看书（这是最容易想到的方法）观看视频教程阅读官网文档读源码到大学蹭课或者报名培训（不知道还算不算自学，没交学费都算吧？） 某君又得纠结一番了，大学蹭课和培训并不一定有合适条件，且不符合自学的气质；观看视频教程，前辈们觉得比较low；阅读官网文档和源码，这不适合初学者。总得来说看书算是比较中肯的方法，至于看什么书呢，前辈推荐了《C Primer Plus》，据说是学习C语言的经典之作。 好吧，不再纠结，直接啃这本大部头，虽然有人说看原版好一些，但是实在能力有限，还是看中文版吧。一口气花了一周时间读完这本书，果然是经典，变量、语句、条件判断甚至指针都知道怎么回事了。 某君决定按照书中的说法实践一下了，于是打开了记事本，折腾很久装了GCC，把书上的第一个例子抄了下来，在控制台的小黑窗输出了“Hello World”，成就感满满。决定上手写点高级的的东西一试身手，合上书。咦，为什么会报错？哦，原来少个分号。不禁陷入思考：为什么学了两个月还是只能在这个黑窗口算算秋水仙数？网友还说要看官网文档、要读源码、要看英文原版，我一样都不能做到，我一定是能力不够，编程果然是天才做的事情…… 正经话 上面的故事是我编的，但其中的纠结却是自学者或多或少都经历过的。实际上，IT从业者并不像传说中那样需要天才般的智商，要点在于能否找到合适的入门途径，再加上一点点坚持和思考。比较可惜的情况是一些人没能找到适合自己的学习方法，并在纠结和碰壁后失去信心，然后沮丧的认定自己并不适合干这行。学编程很多时候就是一个趟坑的过程，但不是每一个坑都有必要趟，写这篇文章的目的是希望能够帮助初学者尽量少趟一些坑。 IT世界的地图 初学者遇到的一个典型问题是对IT世界没有一个大的图景。比如大多数的Java书籍，教完你基础语法知识和秋水仙数的求法后就结束了，并没告诉你接下来能干什么。我曾经为此感到非常困惑，学完Java SE后做了一个非常简陋的GUI demo，就失去了后续的Java学习方向，带着对Java的偏见，这成为了我一段令人沮丧的学习经历。关于这个话题一本书可能都不够，简单来说，我尝试从计算机科学知识和技术实践两方面来聊聊成为一名IT工程师需要具备哪些东西。 计算机科学基础 首先初学者要具备一些非常基础的知识，这些知识在你踏上工作岗位后能被实际的用到，比如计算机运行原理、网络的传输、常用数据结构和算法等。这部分属于计算机科学，也是应该被计算机专业本科课程涵盖的，不要伤心错过了大学本科的相关课程，我会分享一些有用的资源。 这里我罗列了一些计算机专业的学生一般需要学习的课程，当然每个学校专业设计都不一样，甚至采用的教材名字也不一样，仅供参考。大学计算机科学课程往往包括：《高等数学》、《离散数学》、《电子电路》、《数据结构》、《程序设计》、《计算机组成原理》、《编译原理》、《计算机网络》、《软件工程》、《数据库原理》等。有些学校会有一些额外的课程，例如《通信原理》、《汇编语言》、《线性代数》、《C语言》、《Java 语言》等。 图片来源于网易-计算机专业的课程体系 尽管IT行业知识更迭非常快，但是基础知识并不容易过时，因此有大量的资料可以选择。可以选择从计算机经典丛书系列开始，比如佛罗赞和莫沙拉夫的《计算机科学导论》，甚至可以阅读一些计算机科普类读物例如《穿越计算机的迷雾》。另一种直观的方式是观看大学精品课和去跟慕课课程，比较推荐的有几个： 中国大学精品开放课程，高等教育出版社的精品课程项目，有全国大量的名校授课视频和课件中国大学MOOC ，这个是中国大学MOOC和网易合作的，提供了上文附图中计算机课程体系中所有课程果壳网的MOOC学院，主打翻译全球名校的优秀课程，比如斯坦福的《编译原理》和MIT的《Python》 从知识到实践 除此之外，还需要了解实际应用于设计软件或者开发网站中的实践类知识，包括某个特定语言以及周边的库、框架和工具等。 我们可以把特定需求中用到的语言、库和框架以及其他的工具称为技术栈，在技术选型上通常也是被这样考虑的，HR常常会根据技术栈来寻找需要的工程师。比如需要学习SSH三大框架和Java的Java技术栈；为服务器web开发而生的PHP技术栈；在移动开发领域流行的iOS、安卓技术栈等。当然这里面有一些重合和共用的技术也需要学习，比如版本管理器Git、SVN就是每个合格的工程师需要去学习的。 换句话说，大学课程主要定位在上面说到的计算机科学基础知识，而市面上的培训机构主要是告诉你在怎么在实际工作中运用，所以大学和培训机构都有他们的价值。 想要更加详细的了解这部分内容，这里有一些开源的技能图谱可以参考: 如何挑选你的兵器？ 在介绍完计算机领域的大致图景后，就需要选择一门合适的编程语言，一个较为形象的例子是把编程语言比喻成兵器，因为我们深知编程语言对于工程师而言是实实在在的工具，我们不是为了学它而学，学编程不仅仅是学语言特性，一般来说我们也不用知道赋值语句像“茴香豆蔻”的“茴”字有四种写法。 当然语言之争从来没有停止过，如果把编程语言比喻江湖武器的话十分有趣。 C语言是M1式加兰德步枪，很老但可靠。 C++是双截棍，挥舞起来很强悍，很吸引人，但需要多年的磨练来掌握，很多人希望改用别的武器。 Perl语言是燃烧弹，曾经在战场上很有用，但现在很少人使用它。 Java是M240通用弹夹式自动机枪，有时它的弹夹是圆的，但有时候不是，如果不是，当你开火时，会遇到NullPointerException问题，枪会爆炸，你就会被炸死。 JavaScript是一把宝剑，但没有剑柄。 — 来自网络 老实来讲IT行业的最终目的是交付可用的软件，编程语言也是适应市场的。这对于初学者或许有些残酷，在工作中我们发现最好的语言是用来处理工作任务或者构建合适的应用，并不是出于爱好或者某种Geek精神。 对于初学者而言，在选择合适的入门语言时至少需要考虑两点： 是否能适用于构建你想要的应用。如果你的目标是创建一个运行在iPhone上的App，那么最好选择 Objective-C 或者 Swift，学习web开发可以选择PHP或者JAVA。实际上我们仍然可以用汇编做出网页，但是这样做成本高昂。是否容易学习，在满足第一点的条件下请尽量选择容易学习的语言。容易不仅仅指语法简单，包括环境搭建、部署等都需要考虑在内，以及能不能容易找到好的学习资料，因此尽可能的选择主流语言。 别忘了非常重要的一点，学习编程语言还包括平台提供的API，比如Win 32 之于C++/C#/VB，以及周边的库和框架（这些库、框架和工具能在上面说的技术图谱中找到）。IT历史上甚至出现框架和库引领编程语言走向的情况：jQuery和Angular改变了前端开发的思想；Rails抢走了Ruby的名气；而SSH三大框架一度代表了Java世界。 最后我为初学者整理了一个流行编程语言和用途的表： 另外还需要注意的是开发工具，可以选用IDE和有代码提示的编辑器，但尽量不要在这上喋喋不休，这就像用来盛放你锋利兵器的架子，用着顺手就行，也不推荐使用纯文本编辑器，这看起来像赤手空拳。 推荐一些编辑器和IDE 挑选合适的资料和有效的阅读 对初学者而言，我仍然推荐好的视频教程，虽然我已经听到不下5个人声称是靠阅读官方文档或者看源码学会编程的，而且认为观看视频教程见效太慢。但这个思想对初学者很危险，不得不承认阅读文档和源码能更准确找到自己想要的信息，这对深入技术原理非常有用，但视频能比文字传达出更丰富的内容，有更直观的演示和细致的讲解，我想没有比这个更适合初学者了。 除了上面提到的精品课程和慕课教程，国内有像网易云课堂，国外有lynda.com这种在线学习视频网站，甚至在优酷和土豆都能找到足够的教程资源。 如果选择了阅读技术类书籍，我们来聊聊怎么有效的阅读一本技术书籍。 读IT类书籍和读考试类书籍的方式不同，初学者需要选择更接地气、并且能告诉你最终能做出什么案例的书籍。你不需要通读整本书，而是需要搭建好和书中版本一致的环境，然后把书中的每行代码敲入电脑，观察这些代码怎样被运行，在遇到问题时去请教朋友或者到搜索引擎中寻找解决办法，直到示例程序能被正确运行。 可能一个月才能读完一本书，但慢点并没什么坏处，敲过一遍的代码才能算是你的，否则永远存在于纸上的代码清单中。对于关键的概念和知识点，可以在阅读的同时做一些笔记，去尝试使用思维导图来做你的笔记吧，这让你的笔记跟上你的思考，并形成一个知识网络。 自我激励 自学无疑是寂寞的。编程学习耗时较长，如何保证在这个阶段能坚持下去？ 我们知道很多人都能对游戏产生强烈的兴趣、愿意为之投入时间，这其中的秘密就是游戏的奖励规则。杀死一个怪物就能得到一些金币，通过完成任务获得满足感，通过关卡的设计产生持续吸引力，进而形成正向的反馈。 其实学习编程也一样，实现一小段程序并运行，足以让人感到成就感和满足，借鉴这个简单的心理学技巧，定期给自己设定一些有实际意义但是不太难的目标和任务。太难会让人失去耐心，太简单又很无聊，最好设定一个跳起来刚好摸得着的任务。每完成一个目标就给予自己奖励，可以是完成任务的成就感，也可以是其他的物质奖励。 这个时候一个代办记事的清单就可以帮上忙了，可以是一个to do list的软件，或者自己手写一张卡片贴到墙上，关键在于不要忘了在任务达成后给予自己适当的奖励。 那如果真的遇到一些麻烦的任务呢，如何顺利解决而不至于丧失信心？笛卡尔在《方法论》一书中告诉了我们研究复杂问题的方法和步骤: 尽量将其分解为多个比较简单的小问题，一个一个地分开解决将小问题从简单到复杂排列，先从容易解决的问题着手子问题被解决后，进行联调测试，看是否能协同运行 在敏捷开发这种工程思想中我们正是这样做的，我们需要把业务需求进行拆分然后评估工作量，不仅可以直观的看到任务进展，手上的工作也不会看起来庞大得难以完成。 最后多说几句 非科班出身的工程师入门是有一定痛苦的，不像武侠世界里面的名门正派弟子，也没有机缘遇到骨骼精奇的世外高人，如何选择合适自己的学习方式并自我管理是很重要的一方面。没有任何Low的学习方式，只要直接而又高效，而且要能达到我们的目的就好。以我为例，从大专学校毕业并没有机会参加本科课程，曾经也在网上攫取各种视频教程，去别的学校蹭课，甚至带上礼物去一个老师那里登门拜访补课。 另一方面是如何上桌，吃上编程这碗饭。学习的成果如果无处施展便成为屠龙之技，参加一些开源项目和一些公益活动，谁不喜欢一个热心的人呢。也可以尝试去实现自己的一些idea，当做一个小项目来开发，有了一些项目实践后去找一个公司实习会容易的多。 我不知道算是有幸还是不幸经历了这一个过程，矫情一点来说是有一些曲折，但是我知道“聪明”从来不是这个行业的门槛。引用流行于知乎的一句老话“以大多人的努力程度，还轮不到拼天赋的程度”，在Thoughtworks有大量优秀的工程师，从他们身上我能看到聪明不是学习编程成功的关键，坚持和勤于思考才是。 原文地址","categories":[],"tags":[{"name":"未分类","slug":"未分类","permalink":"http://yoursite.com/tags/未分类/"}]},{"title":"抓取哔哩哔哩直播弹幕","slug":"wireshark/wireshark-01","date":"2018-04-10T04:37:08.601Z","updated":"2018-04-24T06:37:30.639Z","comments":true,"path":"wireshark/wireshark-01.html","link":"","permalink":"http://yoursite.com/wireshark/wireshark-01.html","excerpt":"","text":"1.打开谷歌浏览器，找到需要抓取的bilibili直播页面，按F12打开开发者工具，再次刷新当前直播页面， 2.将Method设置为显示，点击排序，找到Method为Post的msg请求 3.这里可以找到侧边栏的弹幕信息，这里的返回数据有十条，如果观看的人数较少，返回的数据会有重复 4.这里是请求地址及请求方式 5.这里包含着需要提交的form表单数据，这里的roomid有时和当前直播网址的尾号不一样 123456789101112131415161718192021# -*- coding: utf-8 -*-import requestsimport time# 请求弹幕的地址url = 'https://api.live.bilibili.com/ajax/msg'# 要提交的form表单数据form = &#123;'roomid': '478948', 'csrf_token': 'b0a925f32a985f10b8ec0fcb3d1'&#125;# 每隔一段时间请求一次，while True: time.sleep(2) # 还可以写成requests.request('POST', url, data=form) response = requests.post(url, data=form) # 将弹幕的内容提取到列表 content = list(map(lambda i: response.json()['data']['room'][i]['text'], range(10))) for i in content: print(i) 12345content = list(map(lambda i: response.json()['data']['room'][i]['text'], range(10)))# 跟下面的代码是一样的含义：content = []for i in range(10): content.append(response.json()['data']['room'][i]['text'])","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/抓包/"}]},{"title":"python爬取budejie.com视频[静态网页]","slug":"python/python-02","date":"2018-04-08T14:42:07.659Z","updated":"2018-04-24T06:37:25.953Z","comments":true,"path":"python/python-02.html","link":"","permalink":"http://yoursite.com/python/python-02.html","excerpt":"","text":"下面的代码用python2写的，稍微改改python3下就可以使用了 python3下没有urllib2，可以用requests替代，这里没有写目录是否存在的判断，需要提前创建目录， 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-# 下面的代码用来下载http://www.budejie.com/video目录下的视频，通过加上页面号码，实现页面跳转下载import urllib2, urllib, re# def getVideo(page):# req = urllib2.Request('http://www.budejie.com/video/'+page) # 传入需要解析的界面地址# req.add_header('User-Agent','Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36')# html = urllib2.urlopen(req).read()# reg = r'data-mp4=\"(.*?)\"'## # 这里可以添加一个判断，只要i&lt;20就说明已到达尾页# for i in re.findall(reg, html): # 下载当前页面的mp4到桌面的文件夹# print '正在下载%s' %i# filename = i.split(\"/\")[-1]# urllib.urlretrieve(i, \"C:/Users/Asus/Desktop/budejie_mp4/\" + filename)## for i in range(1, 101):# getVideo(i)# 简短版本for i in range(1, 101): for i in re.findall(r'data-mp4=\"(.*?)\"', urllib2.urlopen(urllib2.Request('http://www.budejie.com/video/%s'%i, headers=&#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36'&#125;)).read()): urllib.urlretrieve(i, \"C:/Users/Asus/Desktop/budejie_mp4/\" + i.split(\"/\")[-1])","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"Windows下安装PHP开发环境","slug":"php/php-01","date":"2018-04-08T11:48:48.553Z","updated":"2018-04-17T12:18:41.330Z","comments":true,"path":"php/php-01.html","link":"","permalink":"http://yoursite.com/php/php-01.html","excerpt":"","text":"一、Apache ​ 因为Apache官网只提供源代码，如果要使用必须得自己编译，这里我选择第三方安装包Apache Lounge。 进入Apachelounge官方下载地址：http://www.apachelounge.com/download/ 首先下载并安装vc redist，这是Apache运行必需的一个组件。 下载Apache解压版，将解压后的文件夹放在你想要安装的路径下。 修改配置文件： ​ Apache默认存在路径：“c:\\Apache24” 下（版本号可能不同）。如果跟你的安装路径不同，你需要打开Apach\\conf\\httpd.conf配置文件，将其中所有前面没有被”#”注释的”c:\\Apache24”、”c:\\Apache24\\htdocs”和”c:\\Apache24\\cgi-bin\\”改成对应的路径。 ​ 指定IP和端口：在httpd.conf找到”ServerName www.example.com:80“，将前面的注释去掉，将”www.example.com“修改为”localhost”。如果你要修改端口，将这里”80”和前面“Listen：80”中的80一起修改。 （可选）添加系统变量：将”Apache的安装路径\\bin”添加到Path中。 验证安装是否成功：运行Apache的启动httpd.exe。在浏览器上输入localhost:80，如果不是无法访问那么Apache的配置便完成了。 二、PHP 安装配置PHP 进入PHP下载地址http://windows.php.net/download下载最新线程安全版PHP zip压缩包，解压缩后放在想要安装的路径下。注意：下载的PHP VC版本不能比前面安装的vc redist版高。 进入PHP安装目录，复制一份php.ini-development改名为php.ini放到安装路径下，打开找到”extension_dir”，去掉注释符，将值改为”PHP安装路径\\ext” 在Apache中加载PHP 打开Apache的配置文件conf\\httpd.conf，找到LoadModule区域，在其后加入： ​ LoadModule php7_module &quot;PHP安装路径\\php7apache2_4.dll&quot; # 在Apache中以module的方式加载PHP，“php7_module”中的“7”要和PHP的版本对应；此外，不同的PHP版本“php7apache2_4.dll”可能不同。 ​ PHPIniDir &quot;PHP安装路径&quot; #告诉Apache PHP的安装路径 定义执行PHP模块的文件 查找 AddType application/x-gzip .gz .tgz，在其下一行添加代码：AddType application/x-httpd-php .php .html：声明.php和.html的文件能执行PHP程序。 测试：在 Apache安装路径\\htdocs下新建文件：test.php，里面编辑：&lt;?php phpinfo(); ?&gt;， 启动Apache， 在浏览器输入：localhost:80/test.php。 三、MySQL 安装：在https://dev.mysql.com/downloads/下载相应安装版本，根据自己的需求安装。 在PHP中加载连接MySQL的程序集：在php.ini extension板块中增加一行extension=php_mysqli.dll。 说明：不同的PHP版本可能提供不同的连接mysq的程序集，去ext文件夹下看看PHP提供的是什么这里就写什么。不同的程序集可能在连接数据库的时候使用的函数也不一样。 测试：在test.php中编辑：&lt;?php $mysqli = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;pwd&quot;) or die(&quot;cannt connet&quot;); ?&gt;，启动数据库，重启Apache，在浏览器端查看，如果没有错误信息便配置正确了。 原文地址","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"详解Tomcat 配置文件server.xml","slug":"server/tomcat-01","date":"2018-04-08T05:18:43.105Z","updated":"2018-04-24T06:35:11.815Z","comments":true,"path":"server/tomcat-01.html","link":"","permalink":"http://yoursite.com/server/tomcat-01.html","excerpt":"","text":"前言Tomcat隶属于Apache基金会，是开源的轻量级Web应用服务器，使用非常广泛。server.xml是Tomcat中最重要的配置文件，server.xml的每一个元素都对应了Tomcat中的一个组件；通过对xml文件中元素的配置，可以实现对Tomcat中各个组件的控制。因此，学习server.xml文件的配置，对于了解和使用Tomcat至关重要。 本文将通过实例，介绍server.xml中各个组件的配置，并详细说明Tomcat各个核心组件的作用以及各个组件之间的相互关系。 说明：由于server.xml文件中元素与Tomcat中组件的对应关系，后文中为了描述方便，“元素”和“组件”的使用不严格区分。 如果觉得文章对你有帮助，欢迎点赞或转载。文章有疏漏之处，欢迎批评指正。 目录一、一个server.xml配置实例 二、server.xml文档的元素分类和整体结构 1、整体结构 2、元素分类 三、核心组件 1、Server 2、Service 3、Connector 4、Engine 5、Host 6、Context 四、核心组件的关联 1、整体关系 2、如何确定请求由谁处理？ 3、如何配置多个服务 五、其他组件 1、Listener 2、GlobalNamingResources与Realm 3、Valve 六、参考文献 一、一个server.xml配置实例server.xml位于$TOMCAT_HOME/conf目录下；下面是一个server.xml实例。后文中将结合该实例讲解server.xml中，各个元素的含义和作用；在阅读后续章节过程中，可以对照该xml文档便于理解。 123456789101112131415161718192021222324252627282930313233343536 1 &lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; 2 &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt; 3 &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" /&gt; 4 &lt;Listener className=\"org.apache.catalina.core.JasperListener\" /&gt; 5 &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; 6 &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; 7 &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; 8 9 &lt;GlobalNamingResources&gt;10 &lt;Resource name=\"UserDatabase\" auth=\"Container\"11 type=\"org.apache.catalina.UserDatabase\"12 description=\"User database that can be updated and saved\"13 factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\"14 pathname=\"conf/tomcat-users.xml\" /&gt;15 &lt;/GlobalNamingResources&gt;16 17 &lt;Service name=\"Catalina\"&gt;18 &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\"19 connectionTimeout=\"20000\"20 redirectPort=\"8443\" /&gt;21 &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;22 &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt;23 &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt;24 &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"25 resourceName=\"UserDatabase\"/&gt;26 &lt;/Realm&gt;27 28 &lt;Host name=\"localhost\" appBase=\"webapps\"29 unpackWARs=\"true\" autoDeploy=\"true\"&gt;30 &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"31 prefix=\"localhost_access_log.\" suffix=\".txt\"32 pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt;33 &lt;/Host&gt;34 &lt;/Engine&gt;35 &lt;/Service&gt;36 &lt;/Server&gt; 二、server.xml文档的元素分类和整体结构1、整体结构server.xml的整体结构如下： 1234567891011 1 &lt;Server&gt; 2 &lt;Service&gt; 3 &lt;Connector /&gt; 4 &lt;Connector /&gt; 5 &lt;Engine&gt; 6 &lt;Host&gt; 7 &lt;Context /&gt;&lt;!-- 现在常常使用自动部署，不推荐配置Context元素，Context小节有详细说明 --&gt; 8 &lt;/Host&gt; 9 &lt;/Engine&gt;10 &lt;/Service&gt;11 &lt;/Server&gt; 该结构中只给出了Tomcat的核心组件，除了核心组件外，Tomcat还有一些其他组件，下面介绍一下组件的分类。 2、元素分类server.xml文件中的元素可以分为以下4类： （1）顶层元素：&lt;Server&gt;和&lt;Service&gt; &lt;Server&gt;元素是整个配置文件的根元素，&lt;Service&gt;元素则代表一个Engine元素以及一组与之相连的Connector元素。 （2）连接器：&lt;Connector&gt; &lt;Connector&gt;代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。 （3）容器：&lt;Engine&gt;&lt;Host&gt;&lt;Context&gt; 容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。 （4）内嵌组件：可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。 下面将详细介绍Tomcat中各个核心组件的作用，以及相互之间的关系。 三、核心组件本部分将分别介绍各个核心组件的作用、特点以及配置方式等。 1、ServerServer元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。一个Server元素中可以有一个或多个Service元素。 在第一部分的例子中，在最外层有一个&lt;Server&gt;元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。 Server的主要任务，就是提供一个接口让客户端能够访问到这个Service集合，同时维护它所包含的所有的Service的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的Service。 2、ServiceService的作用，是在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；其中Connector的作用是从客户端接收请求，Engine的作用是处理接收进来的请求。 在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口，后文会有介绍。 3、ConnectorConnector的主要功能，是接收连接请求，创建Request和Response对象用于和请求端交换数据；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。 通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector： 121 &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;2 &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; （1）通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。 在这个例子中，Tomcat监听HTTP请求，使用的是8080端口，而不是正式的80端口；实际上，在正式的生产环境中，Tomcat也常常监听8080端口，而不是80端口。这是因为在生产环境中，很少将Tomcat直接对外开放接收请求，而是在Tomcat和客户端之间加一层代理服务器(如nginx)，用于请求的转发、负载均衡、处理静态文件等；通过代理服务器访问Tomcat时，是在局域网中，因此一般仍使用8080端口。 （2）通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。Tomcat与Apache等集成的原理如下图(图片来源)： 关于Connector的更多内容，可以参考另一篇文章：详解tomcat的连接数与线程池 4、EngineEngine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。 前面已经提到过，Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。 在第一部分的例子中，Engine的配置语句如下： 11 &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; 其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。 5、Host（1）Engine与HostHost是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。 （2）Host的作用Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。 Host组件代表的虚拟主机，对应了服务器中一个网络名实体(如”www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。 客户端通常使用主机名来标识它们希望连接的服务器；该主机名也会包含在HTTP请求头中。Tomcat从HTTP头中提取出主机名，寻找名称匹配的主机。如果没有匹配，请求将发送至默认主机。因此默认主机不需要是在DNS服务器中注册的网络名，因为任何与所有Host名称不匹配的请求，都会路由至默认主机。 （3）Host的配置在第一部分的例子中，Host的配置如下： 11 &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 下面对其中配置的属性进行说明： name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。 unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。 Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；此外，本例中没有出现的xmlBase和deployOnStartup属性，也与Web应用的自动部署有关；将在下一节(Context)中介绍。 6、Context（1）Context的作用Context元素代表在特定虚拟主机上运行的一个Web应用。在后文中，提到Context、应用或Web应用，它们指代的都是Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。 Context是Host的子容器，每个Host中可以定义任意多的Context元素。 在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。下面介绍一下Tomcat自动部署Web应用的机制。 （2）Web应用自动部署Host的配置 要开启Web应用的自动部署，需要配置所在的虚拟主机；配置的方式就是前面提到的Host元素的deployOnStartup和autoDeploy属性。如果deployOnStartup和autoDeploy设置为true，则tomcat启动自动部署：当检测到新的Web应用或Web应用的更新时，会触发应用的部署(或重新部署)。二者的主要区别在于，deployOnStartup为true时，Tomcat在启动时检查Web应用，且检测到的所有Web应用视作新应用；autoDeploy为true时，Tomcat在运行时定期检查新的Web应用或Web应用的更新。除此之外，二者的处理相似。 通过配置deployOnStartup和autoDeploy可以开启虚拟主机自动部署Web应用；实际上，自动部署依赖于检查是否有新的或更改过的Web应用，而Host元素的appBase和xmlBase设置了检查Web应用更新的目录。 其中，appBase属性指定Web应用所在的目录，默认值是webapps，这是一个相对路径，代表Tomcat根目录下webapps文件夹。 xmlBase属性指定Web应用的XML配置文件所在的目录，默认值为conf/&lt;engine_name&gt;/&lt;host_name&gt;，例如第一部分的例子中，主机localhost的xmlBase的默认值是$TOMCAT_HOME/conf/Catalina/localhost。 检查Web应用更新 一个Web应用可能包括以下文件：XML配置文件，WAR包，以及一个应用目录(该目录包含Web应用的文件结构)；其中XML配置文件位于xmlBase指定的目录，WAR包和应用目录位于appBase指定的目录。 Tomcat按照如下的顺序进行扫描，来检查应用更新： A、扫描虚拟主机指定的xmlBase下的XML配置文件 B、扫描虚拟主机指定的appBase下的WAR文件 C、扫描虚拟主机指定的appBase下的应用目录 &lt;Context&gt;元素的配置 Context元素最重要的属性是docBase和path，此外reloadable属性也比较常用。 docBase指定了该Web应用使用的WAR包路径，或应用目录。需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，docBase不在appBase目录中，才需要指定；如果docBase指定的WAR包或应用目录就在docBase中，则不需要指定，因为Tomcat会自动扫描appBase中的WAR包和应用目录，指定了反而会造成问题。 path指定了访问该Web应用的上下文路径，当请求到来时，Tomcat根据Web应用的 path属性与URI的匹配程度来选择Web应用处理相应请求。例如，Web应用app1的path属性是”/app1”，Web应用app2的path属性是”/app2”，那么请求/app1/index.html会交由app1来处理；而请求/app2/index.html会交由app2来处理。如果一个Context元素的path属性为””，那么这个Context是虚拟主机的默认Web应用；当请求的uri与所有的path都不匹配时，使用该默认Web应用来处理。 但是，需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，不能指定path属性，path属性由配置文件的文件名、WAR文件的文件名或应用目录的名称自动推导出来。如扫描Web应用时，发现了xmlBase目录下的app1.xml，或appBase目录下的app1.WAR或app1应用目录，则该Web应用的path属性是”app1”。如果名称不是app1而是ROOT，则该Web应用是虚拟主机默认的Web应用，此时path属性推导为””。 reloadable属性指示tomcat是否在运行时监控在WEB-INF/classes和WEB-INF/lib目录下class文件的改动。如果值为true，那么当class文件改动时，会触发Web应用的重新加载。在开发环境下，reloadable设置为true便于调试；但是在生产环境中设置为true会给服务器带来性能压力，因此reloadable参数的默认值为false。 下面来看自动部署时，xmlBase下的XML配置文件app1.xml的例子： 11 &lt;Context docBase=\"D:\\Program Files\\app1.war\" reloadable=\"true\"/&gt; 在该例子中，docBase位于Host的appBase目录之外；path属性没有指定，而是根据app1.xml自动推导为”app1”；由于是在开发环境下，因此reloadable设置为true，便于开发调试。 自动部署举例 最典型的自动部署，就是当我们安装完Tomcat后，$TOMCAT_HOME/webapps目录下有如下文件夹： 当我们启动Tomcat后，可以使用http://localhost:8080/来访问Tomcat，其实访问的就是ROOT对应的Web应用；我们也可以通过http://localhost:8080/docs来访问docs应用，同理我们可以访问examples/host-manager/manager这几个Web应用。 （3）server.xml中静态部署Web应用除了自动部署，我们也可以在server.xml中通过元素静态部署Web应用。静态部署与自动部署是可以共存的。在实际应用中，并不推荐使用静态部署，因为server.xml 是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而自动部署可以在Tomcat运行时通过定期的扫描来实现，不需要重启服务器。 server.xml中使用Context元素配置Web应用，Context元素应该位于Host元素中。举例如下： 11 &lt;Context path=\"/\" docBase=\"D:\\Program Files \\app1.war\" reloadable=\"true\"/&gt; docBase：静态部署时，docBase可以在appBase目录下，也可以不在；本例中，docBase不在appBase目录下。 path：静态部署时，可以显式指定path属性，但是仍然受到了严格的限制：只有当自动部署完全关闭(deployOnStartup和autoDeploy都为false)或docBase不在appBase中时，才可以设置path属性。在本例中，docBase不在appBase中，因此path属性可以设置。 reloadable属性的用法与自动部署时相同。 四、核心组件的关联1、整体关系核心组件之间的整体关系，在上一部分有所介绍，这里总结一下： Server元素在最顶层，代表整个Tomcat容器；一个Server元素中可以有一个或多个Service元素。 Service在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；Connector接收请求，Engine处理请求。 Engine、Host和Context都是容器，且 Engine包含Host，Host包含Context。每个Host组件代表Engine中的一个虚拟主机；每个Context组件代表在特定Host上运行的一个Web应用。 2、如何确定请求由谁处理？当请求被发送到Tomcat所在的主机时，如何确定最终哪个Web应用来处理该请求呢？ （1）根据协议和端口号选定Service和EngineService中的Connector组件可以接收特定端口的请求，因此，当Tomcat启动时，Service组件就会监听特定的端口。在第一部分的例子中，Catalina这个Service监听了8080端口（基于HTTP协议）和8009端口（基于AJP协议）。当请求进来时，Tomcat便可以根据协议和端口号选定处理请求的Service；Service一旦选定，Engine也就确定。 通过在Server中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。 （2）根据域名或IP地址选定HostService确定后，Tomcat在Service中寻找名称与域名/IP地址匹配的Host处理该请求。如果没有找到，则使用Engine中指定的defaultHost来处理该请求。在第一部分的例子中，由于只有一个Host（name属性为localhost），因此该Service/Engine的所有请求都交给该Host处理。 （3）根据URI选定Context/Web应用这一点在Context一节有详细的说明：Tomcat根据应用的 path属性与URI的匹配程度来选择Web应用处理相应请求，这里不再赘述。 （4）举例以请求http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。 3、如何配置多个服务通过在Server中配置多个Service服务，可以实现通过不同的端口号来访问同一台机器上部署的不同Web应用。 在server.xml中配置多服务的方法非常简单，分为以下几步： （1）复制元素，放在当前后面。 （2）修改端口号：根据需要监听的端口号修改元素的port属性；必须确保该端口没有被其他进程占用，否则Tomcat启动时会报错，而无法通过该端口访问Web应用。 以Win7为例，可以用如下方法找出某个端口是否被其他进程占用：netstat -aon|findstr “8081”发现8081端口被PID为2064的进程占用，tasklist |findstr “2064”发现该进程为FrameworkService.exe(这是McAfee杀毒软件的进程)。 （3）修改Service和Engine的name属性 （4）修改Host的appBase属性（如webapps2） （5）Web应用仍然使用自动部署 （6）将要部署的Web应用(WAR包或应用目录)拷贝到新的appBase下。 以第一部分的server.xml为例，多个Service的配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243 1 &lt;?xml version='1.0' encoding='utf-8'?&gt; 2 &lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; 3 &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt; 4 &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" /&gt; 5 &lt;Listener className=\"org.apache.catalina.core.JasperListener\" /&gt; 6 &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; 7 &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; 8 &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; 9 10 &lt;GlobalNamingResources&gt;11 &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt;12 &lt;/GlobalNamingResources&gt;13 14 &lt;Service name=\"Catalina\"&gt;15 &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;16 &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;17 &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt;18 &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt;19 &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"20 resourceName=\"UserDatabase\"/&gt;21 &lt;/Realm&gt;22 23 &lt;Host name=\"localhost\" appBase=\"/opt/project/webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt;24 &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt;25 &lt;/Host&gt;26 &lt;/Engine&gt;27 &lt;/Service&gt;28 29 &lt;Service name=\"Catalina2\"&gt;30 &lt;Connector port=\"8084\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;31 &lt;Connector port=\"8010\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;32 &lt;Engine name=\"Catalina2\" defaultHost=\"localhost\"&gt;33 &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt;34 &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"35 resourceName=\"UserDatabase\"/&gt;36 &lt;/Realm&gt;37 38 &lt;Host name=\"localhost\" appBase=\"/opt/project/webapps2\" unpackWARs=\"true\" autoDeploy=\"true\"&gt;39 &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt;40 &lt;/Host&gt;41 &lt;/Engine&gt;42 &lt;/Service&gt;43 &lt;/Server&gt; 再将原webapps下的docs目录拷贝到webapps2中，则通过如下两个接口都可以访问docs应用： http://localhost:8080/docs/ http://localhost:8084/docs/ 五、其他组件除核心组件外，server.xml中还可以配置很多其他组件。下面只介绍第一部分例子中出现的组件，如果要了解更多内容，可以查看Tomcat官方文档。 1、Listener1234561 &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;2 &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" /&gt;3 &lt;Listener className=\"org.apache.catalina.core.JasperListener\" /&gt;4 &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt;5 &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt;6 &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。 监听器可以在Server、Engine、Host或Context中，本例中的监听器都是在Server中。实际上，本例中定义的6个监听器，都只能存在于Server组件中。监听器不允许内嵌其他组件。 监听器需要配置的最重要的属性是className，该属性规定了监听器的具体实现类，该类必须实现了org.apache.catalina.LifecycleListener接口。 下面依次介绍例子中配置的监听器： VersionLoggerListener：当Tomcat启动时，该监听器记录Tomcat、Java和操作系统的信息。该监听器必须是配置的第一个监听器。 AprLifecycleListener：Tomcat启动时，检查APR库，如果存在则加载。APR，即Apache Portable Runtime，是Apache可移植运行库，可以实现高可扩展性、高性能，以及与本地服务器技术更好的集成。 JasperListener：在Web应用启动之前初始化Jasper，Jasper是JSP引擎，把JVM不认识的JSP文件解析成java文件，然后编译成class文件供JVM使用。 JreMemoryLeakPreventionListener：与类加载器导致的内存泄露有关。 GlobalResourcesLifecycleListener：通过该监听器，初始化&lt; GlobalNamingResources&gt;标签中定义的全局JNDI资源；如果没有该监听器，任何全局资源都不能使用。&lt; GlobalNamingResources&gt;将在后文介绍。 ThreadLocalLeakPreventionListener：当Web应用因thread-local导致的内存泄露而要停止时，该监听器会触发线程池中线程的更新。当线程执行完任务被收回线程池时，活跃线程会一个一个的更新。只有当Web应用(即Context元素)的renewThreadsWhenStoppingContext属性设置为true时，该监听器才有效。 2、GlobalNamingResources与Realm第一部分的例子中，Engine组件下定义了Realm组件： 12341 &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt;2 &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"3 resourceName=\"UserDatabase\"/&gt;4 &lt;/Realm&gt; Realm，可以把它理解成“域”；Realm**提供了一种用户密码与web**应用的映射关系，从而达到角色安全管理的作用。在本例中，Realm的配置使用name为UserDatabase的资源实现。而该资源在Server元素中使用GlobalNamingResources配置： 1231 &lt;GlobalNamingResources&gt;2 &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt;3 &lt;/GlobalNamingResources&gt; GlobalNamingResources元素定义了全局资源，通过配置可以看出，该配置是通过读取$TOMCAT_HOME/ conf/tomcat-users.xml实现的。 关于Tomcat域管理的更多内容，可以参考：Realm域管理 3、Valve在第一部分的例子中，Host元素内定义了Valve组件： 11 &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; 单词Valve的意思是“阀门”，在Tomcat中代表了请求处理流水线上的一个组件；Valve可以与Tomcat的容器(Engine、Host或Context)关联。 不同的Valve有不同的特性，下面介绍一下本例中出现的AccessLogValve。 AccessLogValve的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve放在Host下，便可以记录该Host处理的所有请求。AccessLogValve记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve可以与Engine、Host或Context关联；在本例中，只有一个Engine，Engine下只有一个Host，Host下只有一个Context，因此AccessLogValve放在三个容器下的作用其实是类似的。 本例的AccessLogValve属性的配置，使用的是默认的配置；下面介绍AccessLogValve中各个属性的作用： （1）className：规定了Valve的类型，是最重要的属性；本例中，通过该属性规定了这是一个AccessLogValve。 （2）directory：指定日志存储的位置，本例中，日志存储在$TOMCAT_HOME/logs目录下。 （3）prefix：指定了日志文件的前缀。 （4）suffix：指定了日志文件的后缀。通过directory、prefix和suffix的配置，在$TOMCAT_HOME/logs目录下，可以看到如下所示的日志文件。 （5）pattern：指定记录日志的格式，本例中各项的含义如下： %h：远程主机名或IP地址；如果有nginx等反向代理服务器进行请求分发，该主机名/IP地址代表的是nginx，否则代表的是客户端。后面远程的含义与之类似，不再解释。 %l：远程逻辑用户名，一律是”-”，可以忽略。 %u：授权的远程用户名，如果没有，则是”-”。 %t：访问的时间。 %r：请求的第一行，即请求方法(get/post等)、uri、及协议。 %s：响应状态，200,404等等。 %b：响应的数据量，不包括请求头，如果为0，则是””-。 例如，下面是访问日志中的一条记录 pattern的配置中，除了上述各项，还有一个非常常用的选项是%D，含义是请求处理的时间(单位是毫秒)，对于统计分析请求的处理速度帮助很大。 开发人员可以充分利用访问日志，来分析问题、优化应用。例如，分析访问日志中各个接口被访问的比例，不仅可以为需求和运营人员提供数据支持，还可以使自己的优化有的放矢；分析访问日志中各个请求的响应状态码，可以知道服务器请求的成功率，并找出有问题的请求；分析访问日志中各个请求的响应时间，可以找出慢请求，并根据需要进行响应时间的优化。 六、参考文献Tomcat官方文档 《How Tomcat Works》 《深入分析Java Web技术内幕》 Tomcat 6 —— Realm域管理 Tomcat Port 8009 与AJP13协议 使用Jasper引擎解析JSP 原文地址","categories":[],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"fscanf()函数基本用法","slug":"c_cpp/c_cpp-01","date":"2018-04-08T04:58:12.131Z","updated":"2018-04-24T06:34:10.306Z","comments":true,"path":"c_cpp/c_cpp-01.html","link":"","permalink":"http://yoursite.com/c_cpp/c_cpp-01.html","excerpt":"","text":"123456FILE *fp;while(!feof(fp))&#123; fscanf(fp,\"%s%d%lf\",a,&amp;b,&amp;c);//这里%s对应的a不需要加上取地址符号&amp;，因为a为数组名称，其本身就表示该数组的首地址 printf（\"%s%d%lf\",a,b,c）&#125; fscanf能正确操作的txt文件编码方式为ANSI，以下编码方式均不能使函数正常执行：UTF-8，Unicode，Unicode big endian 这里假如说txt文本内的内容为（对应上面三个数据来写）： 12张三 18 1.74。。。 这里数据与数据之间需要以制表符/或者空格分开即可，数据之间就像scanf()函数一样，若以逗号分隔数据，则scanf中也需要加入逗号，例如scanf(&quot;%d,%d&quot;,a,b);再输入数据时就要输入1,5才能正确输入 但这里尝试fscanf()函数之后并未能出现同样的效果，以后解决了再更新 上菜展示一下效果： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int num; char name[20]; double height; FILE *fp; fp = fopen(\"d:\\\\1.txt\", \"r+\");//“r+” 以可读写方式打开文件，该文件必须存在,d:\\\\1.txt表示d盘根目录下的1.txt文件 if (fp == NULL) &#123; printf(\"Cannot open the file!\\n\"); exit(0); &#125; printf(\"学号\\t姓名\\t身高\\n\"); while (!feof(fp)) &#123; fscanf(fp, \"%d%s%lf\", &amp;num, name, &amp;height); printf(\"%d\\t%s\\t%g\", num, name, height); &#125; printf(\"\\n\"); fclose(fp);//要记得关闭文件 return 0;&#125;","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"为hexo的主题添加动态背景","slug":"website/hexo-10","date":"2018-04-07T13:22:58.592Z","updated":"2018-04-24T06:32:20.483Z","comments":true,"path":"website/hexo-10.html","link":"","permalink":"http://yoursite.com/website/hexo-10.html","excerpt":"","text":"别看了，这张图不会动的，，，， 1.这里以hueman主题为例，打开/themes/hueman/layout/common/layout.ejs，添加下面的一坨代码在body中（如果js的link失效，文末有下载连接）， 123&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 如果使用本地js，可以复制js代码，到主题文件夹下的/source/js目录下 再将上面的代码改为 123&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\" src=\"/js/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 2.更改配置文件 打开主题目录下的_config.yml，在尾部添加下列代码： 1canvas_nest: true 重新部署，即可看见效果。 原文地址 canvas-nest.min.js","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"为hexo主题添加顶部进度加载条","slug":"website/hexo-09","date":"2018-04-07T13:01:37.358Z","updated":"2018-04-24T06:32:24.855Z","comments":true,"path":"website/hexo-09.html","link":"","permalink":"http://yoursite.com/website/hexo-09.html","excerpt":"","text":"最终效果，见文末。 使用Everything在根目录下搜索head.ejs或head.swig，取决于你使用的主题所采用的引擎，如果是hueman主题，就是/themes/hueman/layout/common/head.ejs，如果是next主题就是/themes/next/layout/_partials/head.swig。 实现方法： 在文件的靠前一点的位置添加下面的代码（如果连接打不开，文末有文件的下载地址）： 12&lt;script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"&gt;&lt;/script&gt;&lt;link href=\"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css\" rel=\"stylesheet\"&gt; 默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 如果没有效果，找到主题的配置文件_config.yml，搜索一下是否有pace: false选项，如果有改为true。 原文地址 pace.min.jspace-theme-flash.css","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"为hexo主题添加右键桃心效果","slug":"website/hexo-08","date":"2018-04-07T12:03:19.594Z","updated":"2018-04-24T06:32:06.011Z","comments":true,"path":"website/hexo-08.html","link":"","permalink":"http://yoursite.com/website/hexo-08.html","excerpt":"","text":"最终效果，见文末 步骤： 在/themes/hueman/source/js/中新建一个love.js，复制粘贴下面最大的一坨代码。打开/themes/hueman/layout/layout.ejs将 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt; 粘贴在文件尾部，保存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051!function (e, t, a) &#123; function n() &#123; c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = \"left:\" + d[e].x + \"px;top:\" + d[e].y + \"px;opacity:\" + d[e].alpha + \";transform:scale(\" + d[e].scale + \",\" + d[e].scale + \") rotate(45deg);background:\" + d[e].color + \";z-index:99999\"); requestAnimationFrame(r) &#125; function o() &#123; var t = \"function\" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement(\"div\"); a.className = \"heart\", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement(\"style\"); a.type = \"text/css\"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(\"head\")[0].appendChild(a) &#125; function s() &#123; return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 原文地址","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"浅谈模板引擎","slug":"website/hexo-06","date":"2018-04-07T05:12:08.429Z","updated":"2018-04-17T12:18:41.336Z","comments":true,"path":"website/hexo-06.html","link":"","permalink":"http://yoursite.com/website/hexo-06.html","excerpt":"","text":"模板原理模板的诞生是为了将显示与数据分离，模板技术多种多样，但其本质是将模板文件和数据通过模板引擎生成最终的HTML代码。模板技术并不是什么神秘技术，干的是拼接字符串的体力活。模板引擎就是利用正则表达式识别模板标识，并利用数据替换其中的标识符。比如： 1Hello, &lt;%= name%&gt; 数据是{name: &#39;木的树&#39;}，那么通过模板引擎解析后，我们希望得到Hello, 木的树。模板的前半部分是普通字符串，后半部分是模板标识，我们需要将其中的标识符替换为表达式。模板的渲染过程如下： 123456789101112//字符串替换的思想function tmpl(str, obj) &#123; if (typeof str === 'string') &#123; return str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return obj[key]; &#125;); &#125;&#125;var str = \"Hello, &lt;%= name%&gt;\";var obj = &#123;name: \"Lzz\"&#125;; 模板引擎引擎核心上面我们演示是简单的字符串替换，但对于模板引擎来说，要做的事情更复杂些。通常需要以下几个步骤： 利用正则表达式分解出普通字符串和模板标识符，&lt;%=%&gt;的正则表达式为/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g. 将模板标识符转换成普通的语言表达式 生成待执行语句 将数据填入执行，生成最终的字符串 Demo代码如下： 12345678910111213141516//编译的思想function tmpl(str, obj) &#123; if (typeof str === 'string') &#123; var tm = str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"' + obj.\" + key; // 在函数字符串中利用'包裹正常字符串 &#125;); tm = \"return '\" + tm; //\"'Hello' + obj.name\" var compile = new Function('obj', tm); return compile(obj); &#125;&#125;var str = \"Hello, &lt;%= name%&gt;\";var obj = &#123;name: \"Lzz\"&#125;; // Hello, Lzz 模板编译上述代码中有如下部分： 12tm = \"return '\" + tm; //\"'Hello' + obj.name\"var compile = new Function('obj', tm); 为了能够与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象。这个过程称为模板编译。模板编译使用了new Function(), 这里通过它创建了一个函数对象，语法如下: 1new Function(arg1, arg2,..., functionbody) Function()构造函数接受多个参数，最后一个参数作为函数体的内容，其之前的参数全部作为生成的新函数的参数。需要注意的是Function的参数全部是字符串类型，函数体部分对于字符串跟函数表达式一定要区分清楚,初学者往往在对函数体字符串中的普通字符串和表达式的拼接上犯错。一定要将函数体字符串和内部字符串正确拼接，如： 1new Function('obj', \"return 'Hello,' + obj.name\") 或者对其中的字符换使用\\&quot; 1new Function('obj', 'strip', \"var tmp = \\\"\\\"; with(obj)&#123; tmp = '';for(var i = 0; i &lt; 3; i++)&#123; tmp+='name is ' + strip(name) +' ';&#125; tmp+=''; &#125; return tmp;\") 模板编译过程中每次都要利用Function重新生成一个函数，浪费CPU。为此我们可以将函数缓存起来，代码如下： 1234567891011121314151617181920212223//模板预编译var tmpl = (function()&#123; var cache = &#123;&#125;; return function(str, obj)&#123; if (!typeof str === 'string') &#123; return; &#125; var compile = cache[str]; if (!cache[str]) &#123; var tm = str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"' + obj.\" + key; &#125;); tm = \"return '\" + tm; //\"'Hello' + obj.name\" compile = new Function('obj', tm); cache[str] = compile; &#125; return compile(obj); //预编译情况下应该返回compile函数 &#125;&#125;());var str = \"Hello, &lt;%= name%&gt;\";var obj = &#123;name: \"Lzz\"&#125;;tmpl(str, obj); 利用with利用with我们可以不用把模板标识符转换成obj.name,只需要保持name标识符即可。 12345678910111213141516171819202122232425// 利用with使得变量自己寻找对象, 找不到的视为普通字符串// 貌似return后面不能直接跟with//模板预编译var tmpl = (function()&#123; var cache = &#123;&#125;; return function(str, obj)&#123; if (!typeof str === 'string') &#123; return; &#125; var compile = cache[str]; if (!cache[str]) &#123; var tm = str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"' + \" + key; &#125;); tm = \"var tmp = \\\"\\\"; with(obj)&#123; tmp = '\" + tm + \"; &#125; return tmp;\"; //\"'Hello' + obj.name\" compile = new Function('obj', tm); cache[str] = compile; &#125; return compile(obj); //预编译情况下应该返回compile函数 &#125;&#125;());var str = \"Hello, &lt;%= name%&gt;\";var obj = &#123;name: \"LZZ\"&#125;;tmpl(str, obj); XSS漏洞如果上面的obj变成var obj = {name: &quot;&lt;script&gt;alert(\\&quot;XSS\\&quot;)&lt;/script&gt;&quot;};,那么最终生成的结果就会变成： 1\"Hello, &lt;script&gt;alert(\"XSS\")&lt;/script&gt;\" 为此我们需要堵上这个漏洞，基本就是要将形成HTML标签的字符转换成安全的字符，这些字符通常是&amp;, &lt;, &gt;, &quot;, &#39;。转换函数如下： 12345678var strip = function(html) &#123; return String(html) .replace(/&amp;/g, '&amp;amp;')//&amp; .replace(/&lt;/g, '&amp;lt;')//左尖号 .replace(/&gt;/g, '&amp;gt;')//右尖号 .replace(/\"/g, '&amp;quot;')//双引号\" .replace(/'/g, '&amp;#039;');//IE下不支持&amp;apos;'&#125; 这样下来，模板引擎应该变成这样： 1234567891011121314151617181920212223242526272829303132333435363738var tmpl = (function()&#123; var cache = &#123;&#125;; var strip = function(html) &#123; return String(html) .replace(/&amp;/g, '&amp;amp;')//&amp; .replace(/&lt;/g, '&amp;lt;')//左尖号 .replace(/&gt;/g, '&amp;gt;')//右尖号 .replace(/\"/g, '&amp;quot;')//双引号\" .replace(/'/g, '&amp;#039;');//IE下不支持&amp;apos;' &#125; return function(str, obj)&#123; if (!typeof str === 'string') &#123; return; &#125; var compile = cache[str]; if (!cache[str]) &#123; //var tm = str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; // var key = arguments[1]; // return \"' + strip(\" + key + \")\"; //&#125;); var tm = str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var code = arguments[1]; return \"' + strip(\" + code + \")\"; //利用escape包裹code &#125;).replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"' + \" + key; &#125;); tm = \"var tmp = \\\"\\\"; with(obj)&#123; tmp = '\" + tm + \"; &#125; return tmp;\"; //\"'Hello' + obj.name\" compile = new Function('obj', 'strip', tm); cache[str] = compile; &#125; return compile(obj, strip); //预编译情况下应该返回compile函数 &#125;&#125;());var str = \"&lt;%= name%&gt;\";var obj = &#123;name: \"&lt;script&gt;alert(\\\"XSS\\\")&lt;/script&gt;\"&#125;;tmpl(str, obj); 这时候我们得到如下结果: 1\"&amp;lt;script&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/script&amp;gt;\" 模板逻辑功能稍微强大的模板引擎，都允许在模板中添加一部分逻辑来控制页面的最终渲染。如： 1var str = \"&lt;%for(var i = 0; i &lt; 3; i++)&#123;%&gt;name is &lt;%= name%&gt; &lt;%&#125;%&gt;\"; 这里我们用&lt;%%&gt;代表逻辑代码&lt;%=%&gt;代表模板中需要替换的标识符。我们的模板代码变成了如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142//模板逻辑var tmpl = (function()&#123; var cache = &#123;&#125;; var strip = function(html) &#123; return String(html) .replace(/&amp;/g, '&amp;amp;')//&amp; .replace(/&lt;/g, '&amp;lt;')//左尖号 .replace(/&gt;/g, '&amp;gt;')//右尖号 .replace(/\"/g, '&amp;quot;')//双引号\" .replace(/'/g, '&amp;#039;');//IE下不支持&amp;apos;' &#125; return function(str, obj)&#123;debugger; if (!typeof str === 'string') &#123; return; &#125; var compile = cache[str]; if (!cache[str]) &#123; //var tm = str.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; // var key = arguments[1]; // return \"' + strip(\" + key + \")\"; //&#125;); var tm = str.replace(/&lt;%\\s*([^=][^%&gt;]*)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"';\" + key + \" tmp+='\"; // 逻辑代码需要一块块的拼接起来，为的是拼接成一段合理的函数字符串传递给new Function &#125;).replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var code = arguments[1]; return \"' + strip(\" + code + \") +'\"; //利用escape包裹code ,加入模板逻辑时要注意，保证拼接成正确的函数字符串 &#125;).replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"' + \" + key + \"+ '\";//加入模板逻辑时要注意，保证拼接成正确的函数字符串 &#125;);debugger; tm = \"var tmp = \\\"\\\"; with(obj)&#123; tmp = '\" + tm + \"'; &#125; return tmp;\"; //\"'Hello' + obj.name\" compile = new Function('obj', 'strip', tm); cache[str] = compile; &#125; return compile(obj, strip); //预编译情况下应该返回compile函数 &#125;&#125;());var str = \"&lt;%for(var i = 0; i &lt; 3; i++)&#123;%&gt;name is &lt;%= name%&gt; &lt;%&#125;%&gt;\";var obj = &#123;name: \"&lt;script&gt;alert(\\\"XSS\\\")&lt;/script&gt;\"&#125;;tmpl(str, obj); 第一步，我们将模板中的逻辑表达式找出来，用的正则表达式是/&lt;%\\s*([^=][^%&gt;]*)\\s*%&gt;/g 1234str.replace(/&lt;%\\s*([^=][^%&gt;]*)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"';\" + key + \" tmp+='\"; // 逻辑代码需要一块块的拼接起来，为的是拼接成一段合理的函数字符串传递给new Function &#125;) 注意在拼接时，为了防止函数字符串中的字符串没有闭合对表达式造成影响，我们在key前后都加了&#39;来保证其中的字符串闭合。第二步, 对可能存在的HTML标签进行转义 1234.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var code = arguments[1]; return \"' + strip(\" + code + \") +'\"; //利用escape包裹code ,加入模板逻辑时要注意，保证拼接成正确的函数字符串 &#125;) 同样需要注意前后的字符串闭合第三步，像先前一样处理模板标识符 1234.replace(/&lt;%=\\s*([^%&gt;]+)\\s*%&gt;/g, function() &#123; var key = arguments[1]; return \"' + \" + key + \"+ '\";//加入模板逻辑时要注意，保证拼接成正确的函数字符串 &#125;) 仍然要注意其中的字符串闭合问题。 模板引擎是一个系统的问题，复杂模板还支持模板嵌套，这里就不介绍了，希望此文能够抛砖引玉，让大火带来更好的干货！ 原文地址","categories":[],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"http://yoursite.com/tags/模板引擎/"}]},{"title":"从零开始制作 Hexo 主题","slug":"website/hexo-05","date":"2018-04-07T04:17:14.000Z","updated":"2018-04-24T06:32:16.133Z","comments":true,"path":"website/hexo-05.html","link":"","permalink":"http://yoursite.com/website/hexo-05.html","excerpt":"","text":"写在前面本文将会从零开始开发一个简单的博客主题。样式主要参考 Hexo theme 中的 Noise 主题。 开始之前你需要了解： 模板引擎 CSS预处理器 Hexo 文档 本文使用的模板引擎为 ejs，使用的 CSS 预处理器为 stylus。这也是 hexo 项目预装了的 render 插件，如果想使用其他模板引擎或者其他 CSS 预处理器，可以安装相对应的 render 插件。例如我的 Even 主题使用的是 Swig 与 SCSS。 本文的代码： theme-example 。 目录结构主题目录结构以自带的 landscape 主题为例： 12345.├── languages 语言文件，用于国际化├── layout 页面模板文件├── scripts Hexo 脚本└── source 主题资源文件，包括页面样式，脚本，字体等 我们在 themes 中新建 theme-example 文件夹，然后在 theme-demo 中按照 landscape 主题的目录结构新建 languages，layout，scripts 与 source 文件夹。 创建布局模板在 layout 中创建 index.ejs 文件，首页将会使用该布局模板生成 HTML 文件。 layout/index.ejs: 12345678910&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"&gt; &lt;meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\"&gt; &lt;title&gt;Home&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Word&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 修改站点配置文件中的主题配置，使用我们刚刚创建的 theme-example 主题： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: theme-example 运行 hexo server --debug 以 debug 模式开启 Hexo 本地服务器预览，访问 http://localhost:4000/。 添加页面导航现在我们需要在页面中添加导航，由于导航不单单会在首页出现，所以我们在 layout 中创建共用的布局文件 layout.ejs， 同时创建 _partial/head.ejs 保存 HTML 的 head 以及创建 _partial/header.ejs 文件，编写页面导航部分。 layout/layout.ejs: 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;%- partial('_partial/head') %&gt; &lt;body&gt; &lt;%- partial('_partial/header') %&gt; &lt;main class=\"main\"&gt; &lt;%- body %&gt; &lt;/main&gt; &lt;/body&gt;&lt;/html&gt; layout.ejs 文件通过 partial() 函数来包含其他文件，使得我们能够更好的组织代码。详见 Templates | Hexo。 layout/_partial/head.ejs: 12345&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"&gt; &lt;meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\"&gt; &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt;&lt;/head&gt; 这里使用了 config 变量，该变量包含的是站点配置（即站点根目录下 _config.yml 中的配置）。除此之外，Hexo 还提供了许多变量可在模板中使用，详见 Variables | Hexo。 layout/_partial/header.ejs: 123456789101112131415&lt;header class=\"header\"&gt; &lt;div class=\"blog-title\"&gt; &lt;a href=\"&lt;%- url_for() %&gt;\" class=\"logo\"&gt;&lt;%= config.title %&gt;&lt;/a&gt; &lt;/div&gt; &lt;nav class=\"navbar\"&gt; &lt;ul class=\"menu\"&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"/\" class=\"menu-item-link\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"/archives\" class=\"menu-item-link\"&gt;Archive&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; 接着我们清空 index.ejs 中的内容，并添加 &lt;h2&gt;Hello World&lt;/h2&gt;。在 layout 目录下的 index.ejs 会自动继承 layout.ejs，并将其中的内容填入 &lt;%- body %&gt; 的位置。我们将得到一个有导航菜单的 Hello World 页面。 添加主题配置文件实际上我们需要让导航菜单根据我们的需要显示不同的项，上面这种写法不方便修改。所以我们会在主题的配置文件中添加导航菜单的配置。在 thmem-demo 下新建主题的配置文件 _config.yml，在其中添加需要配置的字段。然后可以通过 theme 这个变量来拿到该配置文件中的配置。 theme-demo/_config.yml: 123menu: Home: / Archives: /archives 这样我们就可以在 header.ejs 中使用 theme.menu 获取到导航菜单的设置。将 header.ejs 修改为： 1234567891011121314&lt;header class=\"header\"&gt; &lt;div class=\"blog-title\"&gt; &lt;a href=\"&lt;%- url_for() %&gt;\" class=\"logo\"&gt;&lt;%= config.title %&gt;&lt;/a&gt; &lt;/div&gt; &lt;nav class=\"navbar\"&gt; &lt;ul class=\"menu\"&gt; &lt;% for (name in theme.menu) &#123; %&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"&lt;%- url_for(theme.menu[name]) %&gt;\" class=\"menu-item-link\"&gt;&lt;%= name %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; 当需要在导航中添加链接的时候就可以在配置文件中直接添加，例如添加 Github 的链接： 1234menu: Home: / Archives: /archives Github: https://github.com/ahonn 除此之外还可以添加其他需要的配置，例如 RSS，评论等等。 添加首页文章列表接着我们完善首页的模板，使其能够显示文章列表。前面已经说过 Hexo 提供了各种有用的变量，在这里将会使用到 page 这个变量。page 会根据不同的页面拥有不同的属性。具体有什么属性，可以获取到哪些数据可以查看这里。 那么这里我们会使用 page 变量的 posts 属性拿到文章数据的集合。编辑 index.ejs 文件： 123456789101112131415&lt;section class=\"posts\"&gt; &lt;% page.posts.each(function (post) &#123; %&gt; &lt;article class=\"post\"&gt; &lt;div class=\"post-title\"&gt; &lt;a class=\"post-title-link\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"post-content\"&gt; &lt;%- post.content %&gt; &lt;/div&gt; &lt;div class=\"post-meta\"&gt; &lt;span class=\"post-time\"&gt;&lt;%- date(post.date, \"YYYY-MM-DD\") %&gt;&lt;/span&gt; &lt;/div&gt; &lt;/article&gt; &lt;% &#125;) %&gt;&lt;/section&gt; 从 page.posts 中获取单篇文章的数据，并获取文章的标题，内容等数据填充到模板中。处理文章创建时间的时候使用了 date() 函数，这是 Hexo 提供的时间处理的辅助函数。本文中使用到的函数如无特别说明，即为 Hexo 的辅助函数。 文章摘录由于首页显示文章内容时使用的是 post.content，即文章的全部内容。所以首页会显示每一篇文章的内容，实际上我们并不想在首页显示那么多内容，只想显示文章的摘录。 Hexo 提供了 excerpt 属性来获取文章的摘录部分，不过这里需要在文章中添加一个 &lt;!-- more --&gt; 标记。添加了这个标记之后，post.excerpt 将会获取到标记之前的内容。如果没有这个标记，那么 post.excerpt 会是空的。所以我们可以把首页文章内容部分的 post.content 替换成 post.excerpt。 123&lt;div class=\"post-content\"&gt; &lt;%- post.excerpt %&gt;&lt;/div&gt; 添加页面样式到目前为止，我们完成了首页的页面结构，但是并没有添加样式，所以看起来很丑。我们在 source 文件中创建一个 css 文件夹来存放样式文件。 由于 Hexo 在新建项目的时候会安装 hexo-renderer-stylus 这个插件，所以我们无需其他步骤，只需要将样式文件放到 css 文件夹中。Hexo 在生成页面的时候会将 source 中的所有文件复制到生成的 public 文件中，并且在此之前会编译 styl 为 css 文件。 在 css 文件夹中创建 style.styl，编写一些基础的样式，并把所有样式 import 到这个文件。所以最终编译之后只会有 style.css 一个文件。创建 _partial/header.styl 与 _partial/post.style 存放页面导航以及文章的样式，并且在 style.styl中 import 这两个文件。 _partial/header.styl: 1234567891011121314151617181920212223242526272829303132.header &#123; margin-top: 2em display: flex align-items: baseline justify-content: space-between .blog-title .logo &#123; color: #AAA; font-size: 2em; font-family: \"Comic Sans MS\",cursive,LiSu,sans-serif; text-decoration: none; &#125; .menu &#123; margin: 0; padding: 0; .menu-item &#123; display: inline-block; margin-right: 10px; &#125; .menu-item-link &#123; color: #AAA; text-decoration: none; &amp;:hover &#123; color: #368CCB; &#125; &#125; &#125;&#125; _partial/post.style: 123456789101112131415161718192021222324252627282930313233.post &#123; margin: 1em auto; padding: 30px 50px; background-color: #fff; border: 1px solid #ddd; box-shadow: 0 0 2px #ddd;&#125;.posts &#123; .post:first-child &#123; margin-top: 0; &#125; .post-title &#123; font-size: 1.5em; .post-title-link &#123; color: #368CCB; text-decoration: none; &#125; &#125; .post-content &#123; a &#123; color: #368CCB; text-decoration: none; &#125; &#125; .post-meta &#123; color: #BABABA; &#125;&#125; style.styl: 12345678910111213body &#123; background-color: #F2F2F2; font-size: 1.25rem; line-height: 1.5;&#125;.container &#123; max-width: 960px; margin: 0 auto;&#125;@import \"_partial/header\";@import \"_partial/post\"; 最后，我们需要把样式添加到页面中，这里使用了另外一个辅助函数 css(): layout/_partial/head.ejs 123456&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt; &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt; &lt;%- css(&apos;css/style.css&apos;) %&gt;&lt;/head&gt; 至此，我们会看到站点的首页是这个样子的： 添加分页在站点的 source/_post/ 目录下存放的是我们的文章，现在我们把原本的 hello-world.md 复制黏贴 10+ 次，再查看站点首页。会发现，首页只显示了 10 篇文章。 首页显示的文章数量我们可以通过站点配置文件中的 per_page 字段来修改，但是我们不可能把所有文章都放在一页，所以我们现在来添加文章列表的分页。 新建 _partial/paginator.ejs: 12345678&lt;% if (page.total &gt; 1)&#123; %&gt; &lt;nav class=&quot;page-nav&quot;&gt; &lt;%- paginator(&#123; prev_text: &quot;&amp;laquo; Prev&quot;, next_text: &quot;Next &amp;raquo;&quot; &#125;) %&gt; &lt;/nav&gt;&lt;% &#125; %&gt; 在 index.ejs 中添加这个文件的内容： 123...&lt;/section&gt;&lt;%- partial(&apos;_partial/paginator&apos;) %&gt; 这里我们使用到了另外的一个辅助函数 paginator，它能够帮助我们插入分页链接。 添加文章详情页文章详情页对应的布局文件是 post.ejs，新建 post.ejs: 1234567891011&lt;article class=\"post\"&gt; &lt;div class=\"post-title\"&gt; &lt;h2 class=\"title\"&gt;&lt;%= page.title %&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"post-meta\"&gt; &lt;span class=\"post-time\"&gt;&lt;%- date(page.date, \"YYYY-MM-DD\") %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"post-content\"&gt; &lt;%- page.content %&gt; &lt;/div&gt;&lt;/article&gt; 由于这里是文章的模板，所以变量 page 表示的是文章的数据，而不是首页的文章数据集合。 添加归档页创建归档页使用的模板文件 archive.ejs: 1234567891011&lt;section class=\"archive\"&gt; &lt;ul class=\"post-archive\"&gt; &lt;% page.posts.each(function (post) &#123; %&gt; &lt;li class=\"post-item\"&gt; &lt;span class=\"post-date\"&gt;&lt;%= date(post.date, \"YYYY-MM-DD\") %&gt;&lt;/span&gt; &lt;a class=\"post-title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt;&lt;/section&gt;&lt;%- partial('_partial/paginator') %&gt; 其实结构跟首页差不多，只是不显示文章内容而已。添加归档页的样式： css/_partial/archive.styl: 123456789101112131415161718192021222324252627.archive &#123; margin: 1em auto; padding: 30px 50px; background-color: #fff; border: 1px solid #ddd; box-shadow: 0 0 2px #ddd; .post-archive &#123; list-style: none; padding: 0; .post-item &#123; margin: 5px 0; .post-date &#123; display: inline-block; margin-right: 10px; color: #BABABA; &#125; .post-title &#123; color: #368CCB; text-decoration: none; &#125; &#125; &#125;&#125; 国际化还记得我们一开始创建的 languages 文件夹吗？没错，它是用来添加多种语言，用于 i18n 的。站点的语言设置为站点配置文件中的 language。 当该字段为空时，默认使用的是 languages/default.yml 这个文件。那么现在我们来添加这个文件，我们决定主题的默认语言是英文： 12345678Menu: Home: Home Archives: Archives Github: GithubPaginator: Prev: Prev Next: Next 目前我们需要主题根据选择的语言自动修改的有上面这些，接着我们需要修改 header.ejs 与 paginator.ejs 这两个文件： _partial/header.ejs 1234567891011121314&lt;header class=\"header\"&gt; &lt;div class=\"blog-title\"&gt; &lt;a href=\"&lt;%- url_for() %&gt;\" class=\"logo\"&gt;&lt;%= config.title %&gt;&lt;/a&gt; &lt;/div&gt; &lt;nav class=\"navbar\"&gt; &lt;ul class=\"menu\"&gt; &lt;% for (name in theme.menu) &#123; %&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"&lt;%- url_for(theme.menu[name]) %&gt;\" class=\"menu-item-link\"&gt;&lt;%- __('Menu.' + name) %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; _partial/paginator.ejs: 12345678&lt;% if (page.total &gt; 1)&#123; %&gt; &lt;nav class=&quot;page-nav&quot;&gt; &lt;%- paginator(&#123; prev_text: &quot;&amp;laquo;&quot; + __(&apos;Paginator.Prev&apos;), next_text: __(&apos;Paginator.Next&apos;) + &quot;&amp;raquo;&quot; &#125;) %&gt; &lt;/nav&gt;&lt;% &#125; %&gt; 修改之后其实与之前相比没有什么变化，起码看起来是。现在我们添加一个中文的文件： languages/zh-CN.yml 12345678Menu: Home: 首页 Archives: 归档 Github: 交友Paginator: Prev: 上一页 Next: 下一页 然后我们将站点配置文件中的 language 字段修改为 zh-CN（与 zh-CN.yml 文件名相同）。再次访问站点之后就会发现导航与分页部分的文字变成了中文。 最后总结如果你有耐心看我废话了这么多的话，恭喜你，你应该对怎么去写一个 Hexo 主题有了一定的了解。其实说白了，Hexo 就是把那些 Markdown 文件按照不同的布局模板，填上对应的数据生成 HTML 页面，复制 source 中的到生成的 public 文件夹中，中间过程会把需要编译的 stylus/less/sass 等文件编译。 本文并没有提及有关页面 JavaScript 的部分，实际上与写 CSS 样式相同。在 source/js 中写 JavaScript 脚本，然后在模板中引入即可。 感谢阅读，希望对你有所帮助。 原文地址","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo折腾记——自动部署篇","slug":"website/hexo-04","date":"2018-04-07T04:03:28.000Z","updated":"2018-04-24T06:33:10.258Z","comments":true,"path":"website/hexo-04.html","link":"","permalink":"http://yoursite.com/website/hexo-04.html","excerpt":"","text":"目标:写完一键上传并部署。(一个命令完成) 详细流程:上传图片至七牛，上传 deploy 文件至Github公开库 以及 博客源代码 至Github 私有库，Daocloud 检测到commit 自动构建镜像并自动更新应用。 实现:​ 1.在public目录下放置Dockerfile文件: 12FROM daocloud.io/nginxCOPY ./ /usr/share/nginx/html ​ 2.在Daocloud里，创建新的代码构建，并设置成检测到commit就自动构建，再用这个镜像创建新应用，并设置自动更新 ​ 3.hexo根目录下创建 update.sh (Mac/Linux下需修改执行权限: sudo chown 755 ./update.sh， Windows 需改成对应的bat脚本) 1234567891011121314151617181920212223#!/bin/sh# author: joway# 如果参数个数不等于0if test $# -gt 0thenif test $1 = '-img'thencd ./source/photos/node photo-tool.jscd ../../echo 'Upload complete'elseecho 'Parameter error'fielseecho 'No image needs upload'fihexo cleanhexo g &amp;&amp; gulphexo deploygit add .git commit -m 'update backup'git push origin master 命令使用: 1234# 需要上传图片./update.sh -img #图片没改动， 只上传站点文件./update.sh 原文地址","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo折腾记——性能优化篇","slug":"website/hexo-03","date":"2018-04-07T04:03:12.000Z","updated":"2018-04-24T06:33:13.481Z","comments":true,"path":"website/hexo-03.html","link":"","permalink":"http://yoursite.com/website/hexo-03.html","excerpt":"","text":"折腾Hexo的本来目的就是为了学习把性能优化到极致，由于水平有限，这里牵涉到的所谓的性能优化仅仅只是一些表面工夫，并不牵涉非常细节的前端性能。 另外，由于我朝特殊的网络环境，我使用的谷歌分析，以及Disqus 均会导致出现因时因地因运营商而异的发抽状况，故而所有速度测试均在排除这些干扰下进行的。 静态文件压缩静态文件包括: html,css,js,images . 我才用了gulp来跑自动压缩任务 。具体方法如下: 1.npm 安装如下工具, 方法皆为 : npm install xxx –save 123456\"gulp\": \"^3.9.1\",\"gulp-htmlclean\": \"^2.7.6\",\"gulp-htmlmin\": \"^1.3.0\",\"gulp-imagemin\": \"^2.4.0\",\"gulp-minify-css\": \"^1.2.4\",\"gulp-uglify\": \"^1.5.3\", 2.建立 gulpfile.js 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 获取 gulp-imagemin 模块var imagemin = require('gulp-imagemin')// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src('./photos/*.*') // 2. 压缩图片 .pipe(imagemin(&#123; progressive: true &#125;)) // 3. 另存图片 .pipe(gulp.dest('dist/images'))&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js','images']); 注意， 修改上面的各个目录为你的真实目录， ** 代表0或多个子目录 3.执行 gulp ，即可自动压缩所有静态文件 CDN 接入上面的静态文件压缩幅度有限，要先提升下载速率还需要CDN的支持 。 理论上最佳方案是把所有静态文件都放在CDN上，但是由于hexo各处都在调用内部的js/css，如果需要改动，工程量会比较大，后期维护也不是很方便。不知道以后Hexo会不会原生提供一个配置静态资源地址的选项。 所以我这里只将图片放在了七牛CDN上，hexo 有一个七牛的插件 : hexo-qiniu-sync 。 但是不知道为什么， 我在我电脑上跑不来这个，我看网上也有人说这个插件有许多bug，于是我就自己写了个脚本(本来想写插件，但是并没有研究过hexo的插件该如何写，所以暂时放弃了，后期有时间尝试下吧)。 我的需求很简单，我有一个相册的页面，里面可能会放许多图片，我只想要一个脚本，能过一键上传所有图片然后把url全部写进我的相册界面里。具体实现思路参见 Hexo 折腾记(基本配置篇) 。 一键上传所有文件至七牛的Node 脚本在Github上: https://github.com/joway/qiniu_upload_node InstantClick 黑科技说到性能优化，有一个黑科技虽然不是特别优雅，但是提升的速度却是立杆见影且惊人的，那就是 InstantClick 。 InstantClick 的思路非常巧妙，它利用鼠标点击链接前的短暂时间(统计说是平均400ms)进行预加载，从而在感观上实现了迅速打开页面的效果。当你在打开页面的时候，其实页面已经加载到本地了，也就会很快能个完成渲染。 InstantClick 并不能滥用，许多js无法与它兼容，比如 谷歌分析，百度统计，另外还有fancybox 。故而它有两种启用方式: 白名单方式: 初始化: 12&lt;script src=\"instantclick.min.js\"data-no-instant&gt;&lt;/script&gt;&lt;script data-no-instant&gt;InstantClick.init(true);&lt;/script&gt; 针对具体每个链接启动: 1&lt;a href=\"/blog/\" data-instant&gt;Blog&lt;/a&gt; 黑名单方式: 初始化，以及解决部分js无法加载的问题: 12345678910111213141516&lt;script src=\"/js/instantclick.min.js\" data-no-instant&gt;&lt;/script&gt;&lt;script data-no-instant&gt;InstantClick.on('change', function(isInitialLoad) &#123;if (isInitialLoad === false) &#123;if (typeof MathJax !== 'undefined') // support MathJaxMathJax.Hub.Queue([\"Typeset\",MathJax.Hub]);if (typeof prettyPrint !== 'undefined') // support google code prettifyprettyPrint();if (typeof _hmt !== 'undefined') // support 百度统计_hmt.push(['_trackPageview', location.pathname + location.search]);if (typeof ga !== 'undefined') // support google analyticsga('send', 'pageview', location.pathname + location.search);&#125;&#125;);InstantClick.init();&lt;/script&gt; 这时候对于所有链接都开启 预加载模式，但是可以针对部分链接假如黑名单: 1&lt;a href=\"/blog/\" data-no-instant&gt;Blog&lt;/a&gt; 这里我遇到的一个坑是，我的相册使用了fancybox，而对于InstantClick死活无法解决fancybox的问题(网上也没解决方案)，虽然我可以通过指定data-no-instant来达到不预加载的目的，但是hexo对于每个同级链接都是一样对待的，我如何让它单单对于相册不进行预加载呢? 我能够想到的方法就是对导航栏的每一个url指定一个以其中文名(暂时不映射成英文)命名的id值，然后待页面渲染完了以后，对id值为’相册’的元素添加 data-no-instant 属性: 1$(\"#相册\").attr(\"data-no-instant\",''); 有些时候这种加黑名单的方法也没用，那么就用最后一招，强制刷新（自己调试出来的，略土。。） : 123document.getElementById('相册').onclick = function(e)&#123;location.href = document.getElementById('相册').href;&#125; Nginx 优化配置Gzip压缩: 12345678910111213141516http &#123; gzip on; gzip_vary on; gzip_comp_level 6; gzip_buffers 16 8k; gzip_min_length 1000; gzip_proxied any; gzip_disable \"msie6\"; gzip_http_version 1.0; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript; ... ...&#125; 搜索引擎优化(SEO)添加百度主动推送代码，让搜索引擎最快发现文章 . 方法: 在 &lt;博客根目录&gt;/themes/yilia/layout/_partial/article.ejs 的尾部评论位置, 添加: 12345678910&lt;% if (!index)&#123; %&gt;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); bp.src = '//push.zhanzhang.baidu.com/push.js'; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; &lt;% &#125; %&gt; 之后，每次用户访问界面，都会去调用推送代码 原文地址","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo折腾记——基本配置篇","slug":"website/hexo-02","date":"2018-04-07T02:50:23.000Z","updated":"2018-04-24T06:32:59.171Z","comments":true,"path":"website/hexo-02.html","link":"","permalink":"http://yoursite.com/website/hexo-02.html","excerpt":"","text":"前言人闲起来真是可怕，本来已经折腾过了jekyll和Ghost，静态和动态博客也都尝了遍鲜，然而还是按捺不住寂寞又折腾起来Hexo。话说我最早大概是两年前高考结束的时候知道的Hexo，那时在家里没事干想搭个博客玩，然后看见了jekyll和hexo，无奈那时候就一台windows，啥也不懂啥也不会，这两个博客工具楞是装不上去。而Jekyll的一个好处是可以不用在本地跑，Github 的Pages功能原生支持Jekyll，所以我只需要下载些别人的源文件，自己随便修改下，传到Github就能在线调试和运行了。 这次尝试Hexo的另一个原因是，想重头学习下这些工具的原理和逻辑，另外再添加些可以将性能发挥到极致的黑科技(下文会有介绍)。 至于Hexo如何安装配置，网上有太多教程了，可以直接按照文档操作 。 这里只作为进阶，列举一些进阶配置以及踩过的坑。 PS ： 我用的Hexo 版本是3.2, 主题是 yilia 以下功能可能需要插件支持，我的package.json为: 12345678910111213141516171819202122232425262728293031&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.2.0\" &#125;, \"dependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-htmlclean\": \"^2.7.6\", \"gulp-htmlmin\": \"^1.3.0\", \"gulp-imagemin\": \"^2.4.0\", \"gulp-minify-css\": \"^1.2.4\", \"gulp-uglify\": \"^1.5.3\", \"hexo\": \"^3.2.0\", \"hexo-deployer-git\": \"0.0.4\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.0.2\", \"hexo-generator-index\": \"^0.2.0\", \"hexo-generator-sitemap\": \"^1.1.2\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-migrator-rss\": \"^0.1.2\", \"hexo-renderer-ejs\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.10\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-server\": \"^0.2.0\", \"jgallery\": \"^1.5.4\", \"qiniu\": \"^6.1.9\" &#125;&#125; 文章永久链接默认文章链结是以: http://xxx.com/2015/07/06/your-title/ 的格式的， 个人不是很喜欢这样的格式，而且末尾没有.html结尾有点动态页面的感觉，对搜索引擎是否友好也有疑问(如果你知道答案，请告诉我)，于是，我改成了 http://xxx.com/posts/programming/2016-03-18-hello-world.html 这样的格式，具体方法是在 根目录下的 _config.yml 文件里: 1permalink: posts/:category/:year-:month-:day-:title.html 开启目录支持我本人并不是很喜欢以tag来分类文章的方式，但是hexo默认是以tag来分类的，于是我另外给它加了一个种类(Category)的选项，方法是在_config.yml 下: 12345default_category: uncategorizedcategory_map: 编程: programming 生活: life 其他: other 其中, category_map 是为了让url中尽量少出现中文，做的映射。 例如:在文章开头，标柱目录为: 1234---xxx: xxxcategories: 编程--- 则在url中， 会变成: 1.../posts/programming/xxx.html 文章目录默认不开启文章目录，若要开启: 1234---xxx: xxxtoc: true--- 会自动根据标题权重进行目录生成。显示在最右边。 如需要更改格式， 可去 …/yilia/layout/_partial/archive.ejs 中修改 相册一直很想要一个靠谱，方便，而且快捷的相册功能，以前用Jekyll的时候没弄懂如何动态生成界面，就直接用html写了一个相册界面，然后还用VC++写了一个windows下的把某个文件夹下所有图片名检索并自动生成相应的html相册页面的小工具，后来玩Ghost了， 天真地想把发布图片的功能集成到原生的管理面版上，然后最后还是失败了。 这次折腾hexo，我下定决心了一定要把相册功能给实现了!(然后我就浪费了一个下午 :( 一开始贪图方便，使用 yilian 主题 自带的 基于instagram API的相册展示功能，本来还想着如果instagram被墙，试试看反代它的地址来实现功能，后来发现我申请的client_id 死活不能用我也是醉了，最后腾了半天还弄不好我也就放弃了。 于是想自己造轮子，思路很简单，把照片全部放在本地某个目录下，然后跑个Python或者Node脚本把所有文件上传到某个地方(github/七牛)，并把这些文件名全部保存为output.json 文件，之后相册页面通过get 这个json文件，来得到对应的所有照片url，生成界面。(这个流程参照了网上另一位仁兄的实现，然后我找不到链接了…下次找到了补充上来) 看了下七牛的Node SDK 文档，发现都不用写多少代码，直接能照着文档用，于是改了改，放在本地一键运行，成功! 一键上传七牛以及输出文件名json的代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const fs = require(\"fs\"); const path = \"../../photos\"; var qiniu = require(\"qiniu\"); //需要填写你的 Access Key 和 Secret Key qiniu.conf.ACCESS_KEY = 'xxx'; qiniu.conf.SECRET_KEY = 'xxx'; //要上传的空间 bucket = 'hexo'; //构建上传策略函数 function uptoken(bucket, key) &#123; var putPolicy = new qiniu.rs.PutPolicy(bucket+\":\"+key); return putPolicy.token(); &#125; //构造上传函数 function uploadFile(uptoken, key, localFile) &#123; var extra = new qiniu.io.PutExtra(); qiniu.io.putFile(uptoken, key, localFile, extra, function(err, ret) &#123; if(!err) &#123; // 上传成功， 处理返回值 console.log('upload success : ',ret.hash, ret.key); &#125; else &#123; // 上传失败， 处理返回代码 console.log(err); &#125; &#125;); &#125; /** * 读取文件后缀名称，并转化成小写 * @param file_name * @returns */ function getFilenameSuffix(file_name) &#123; if(file_name=='.DS_Store')&#123; return '.DS_Store'; &#125; if (file_name == null || file_name.length == 0) return null; var result = /\\.[^\\.]+/.exec(file_name); return result == null ? null : (result + \"\").toLowerCase(); &#125; fs.readdir(path, function (err, files) &#123; if (err) &#123; return; &#125; var arr = []; (function iterator(index) &#123; if (index == files.length) &#123; fs.writeFile(\"./output.json\", JSON.stringify(arr, null, \"\\t\")); return; &#125; fs.stat(path + \"/\" + files[index], function (err, stats) &#123; if (err) &#123; return; &#125; if (stats.isFile()) &#123; var suffix = getFilenameSuffix(files[index]); if(!(suffix=='.js'|| suffix == '.DS_Store'))&#123; //要上传文件的本地路径 filePath = path+'/'+files[index]; console.log('抓取到文件: '+files[index]); //上传到七牛后保存的文件名 key = files[index]; //生成上传 Token token = uptoken(bucket, key); // 异步执行 uploadFile(token, key, filePath); arr.push(files[index]); &#125; &#125; iterator(index + 1); &#125;) &#125;(0)); &#125;); 一键部署全局 _config.yml 中，设置: 1234deploy: type: git repository: https://github.com/joway/hexo-blog.git branch: master 执行 1hexo deploy 即可上传至git 仓库 原文地址","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"ubuntu常见错误","slug":"ubuntu/ubuntu常见错误","date":"2018-04-07T02:36:33.888Z","updated":"2018-04-24T06:35:55.373Z","comments":true,"path":"ubuntu/ubuntu常见错误.html","link":"","permalink":"http://yoursite.com/ubuntu/ubuntu常见错误.html","excerpt":"","text":"1. Could not get lock /var/lib/dpkg/lock通过终端安装程序sudo apt-get install xxx时出错：E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?出现这个问题可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因可能是上次运行安装或更新时没有正常完成，进而出现此状况，解决的办法其实很简单：在终端中敲入以下两句12sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock 再试着安装，问题解决。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"Python装饰器","slug":"python/python-01","date":"2018-04-06T09:18:26.000Z","updated":"2018-04-24T06:37:23.666Z","comments":true,"path":"python/python-01.html","link":"","permalink":"http://yoursite.com/python/python-01.html","excerpt":"","text":"什么是装饰器在我们的软件产品升级时，常常需要给各个函数新增功能，而在我们的软件产品中，相同的函数可能会被调用上百次，这种情况是很常见的，如果我们一个个的修改，那我们的码农岂不要挂掉了(有人就说了 ，你笨呀，修改函数定义不就行了！同学，你醒醒吧，如果要新加的功能会修改参数，或者返回值呢？)。这个时候，就是我们装饰器大显神通的时候了。装饰器就可以实现，在不改变原函数的调用形式下（即函数的透明化处理），给函数新增功能的作用。如何实现，以及实现原理，下文会详解。 装饰器遵循的原则装饰器，顾名思义就是起装饰的作用，既然是装饰，那么被装饰的对象是啥样就是啥样，不能有丝毫改变。在这里，我们写装饰器就是必须把握不能修改被修饰函数的源代码这条铁律。如何遵循这条铁律，我们还需还需做一些铺垫，必须先要了解三个概念，如下： 函数名即“变量”在python中，函数名其实就像是c语言的函数指针，代表的是我们的函数地址，只有解释器获取到这个地址，它才会去执行这块内存的代码。因此，本质上，函数名就和不同变量没什么区别，只不过函数名和普通变量所指代的那块内存的使用方式不同罢了，这些都是底层解释器的机制所决定的，对于程序猿来说，都是透明的，所以，我们可以认为两者是没有区别的。 高阶函数 什么是高阶函数其实很简单，把握两个原则就好： 形式参数有函数名 返回值有函数名 只要满足这两个原则之一，就可以称之为是高阶函数。翻回头来看，这里出现了我们上面说的函数名，仔细体会一下，我们在这里不就是把其当成实参看待的吗？ 嵌套函数什么是嵌套函数其实也非常简单，把握一个原则就好： 在一个函数的函数体中去定义另一个函数 在这里需要强调的是，函数定义时是不会执行函数体的，就和定义变量是不会去读取变量里的内容一样。这一点至关重要，对于我们理解装饰器实现原理非常有帮助。 如何写装饰器有了上文的铺垫，在现在来详解一下如何写装饰器，就好理解多了。 装饰器本质 其实装饰器本质上就是一个函数，它也具有函数名，参数和返回值。但在python中，我们用“@auth”来表示。 123@auth # 其等价于：func = auth(func)def func(): print(\"func called\") 这个示例就是python中如何修饰func函数的格式，当然我们还没有实现我们的装饰器函数。我们要注意的是注释里写的内容，我们可以看出： 装饰器函数其实是一个高阶函数(参数和返回值都为函数名)。 “auth(func)”是在调用我们的装饰器函数，即装饰器函数的函数体会被执行，一定要记好这一点。 设计思路装饰器即然是个函数，又有上述介绍的等价关系，那我们就可以这样设计我们的装饰器： 在我们装饰器的函数体内去定义一个新的函数，在这个新定义的函数内去调用被修饰的函数，与此同时，在被修饰的函数的上下文去添加新功能。最后，利用装饰器函数的返回值返回我们新定义函数的函数名。 由此可以知道，“func = auth(func)”中的返回值func表示的就是在装饰器中新定义的函数的函数名。 前面做了大量的铺垫，就是想在这里揭示装饰器的实现机制，其实没什么什么的，很简单： 装饰器机制改变了被修饰函数的函数名表示的地址数据。说白了就是，被修饰前，函数名代表的是A内存块；被修饰后，函数名代表的是B内存块；只不过，在执行B内存块时，会调用A内存块罢了。B内存块中的代码就是我们新加的功能。而这种机制的实现，使用了“高阶函数”和“嵌套函数”的机制。 最终的效果就是，但在调用被修饰过的函数时，其实调用的不是原来的内存块，而是修饰器新申请的内存块。 第一步：设计装饰器函数装饰器函数定义跟普通函数定义没什么区别，关键是函数体怎么写的问题。这里，为了便于理解，先用无参数的装饰器函数说明。 1234#装饰器函数定义格式def deco(func): '''函数体...'''return func 这里说的无参数，指的是没有除了“func”之外的参数 难点是函数体的编写，下面的示例先告诉你为什么要有第二步： 1234567891011121314151617181920#使用语法糖@来装饰函数，相当于“myfunc = deco(myfunc)”def deco(func): print(\"before myfunc() called.\") func() print(\"after myfunc() called.\") return func @decodef myfunc(): print(\"myfunc() called.\") myfunc()myfunc() #output：before myfunc() called.myfunc() called.after myfunc() called.myfunc() called.myfunc() called. 由输出结果可以看出，我们的装饰器并没有生效。别跟我说装饰器只生效了一次，那是大家忽略了“@deco”的等效机制。解释到“@deco”时，会解释成“myfunc = deco(myfunc)”。注意了，前面我提到了，这里其实在调用deco函数的，因此，deco的函数体会被执行。所以output的前三行并不是调用myfunc函数时产生的效果，那有怎能说装饰器生效了一次呢？第二步就是解决装饰器没生效的问题的。 第二步：包装被修饰函数12345678#基本格式def deco(func): def _deco() #新增功能 #... #... func() #别修饰函数调用 return_deco 下面给出个示例： 12345678910111213141516171819202122#使用内嵌包装函数来确保每次新函数都被调用，#内嵌包装函数的形参和返回值与原函数相同，装饰函数返回内嵌包装函数对象 def deco(func): def _deco(): print(\"before myfunc() called.\") func() print(\"after myfunc() called.\") # 不需要返回func，实际上应返回原函数的返回值 return _deco @decodef myfunc(): print(\"myfunc() called.\") return 'ok' myfunc() #output:before myfunc() called.myfunc() called.after myfunc() called. 第三步：被修饰函数参数和返回值透明化处理当完成了第二步时，其实装饰器已经完成了主要部分，下面就是对被修饰函数的参数和返回值的处理。这样才能真正实现装饰器的铁律。话不多说，直接上代码： 123456789#基本格式def deco(func): def _deco(*args, **kwargs) #参数透明化 #新增功能 #... #... res = func(*args, **kwargs) #别修饰函数调用 return res #返回值透明化 return_deco 通过上面的分析知： 参数透明化：当我们在调用被装饰后的函数时，其实调用的时这里的_deco函数。那么，我们就给_deco函数加上可变参数，并把得到的可变参数传递给func函数不就可以了。 返回值透明化：和参数透明化同理，给_deco函数定义返回值，并返回func的返回值就可以了。 透明化处理就是这么简单！至此，我们的装饰器编写完成。给个示例吧： 12345678910111213141516171819202122232425262728#对带参数的函数进行装饰，#内嵌包装函数的形参和返回值与原函数相同，装饰函数返回内嵌包装函数对象 def deco(func): def _deco(*agrs, **kwagrs): print(\"before myfunc() called.\") ret = func(*agrs, **kwagrs) print(\" after myfunc() called. result: %s\" % ret) return ret return _deco @decodef myfunc(a, b): print(\" myfunc(%s,%s) called.\" % (a, b)) return a + b print(\"sum=\",myfunc(1, 2))print(\"sum=\",myfunc(3, 4)) #output:before myfunc() called. myfunc(1,2) called. after myfunc() called. result: 3sum= 3before myfunc() called. myfunc(3,4) called. after myfunc() called. result: 7sum= 7 装饰器进阶带参数装饰器装饰器即然也是函数，那么我们也可以给其传递参数。我这里说的是：“@auth(auth_type = ‘type1’)”这中形式哟。先上个代码吧： 123456789101112#基本格式def deco(deco_type) def _deco(func): def __deco(*args, **kwargs) #参数透明化 #新增功能 #... #... print(\"deco_type:\",deco_type) #使用装饰器参数 res = func(*args, **kwargs) #别修饰函数调用 return res #返回值透明化 return __deco return _deco 说白了，就是在原来的装饰器的基础上再在最外层套一个deco函数，并用其来接收装饰器参数。由于是在最外层套了一个函数，那么这个函数的形参的作用范围就是函数体内部，所以里面的函数定义中随便用啦，就这么任性。 那怎么理解解释器的解析过程呢？在这里，只要我们明白一点就好，那就是：“@auth(auth_type = ‘type1’)”等价于“func = auth(auth_type = ‘type1’)(func)”。解释器会先翻译“auth(auth_type = ‘type1’)”，再将其返回值(假设给了_func这个不存在的函数名)当作函数指针，这里的_func函数名代表的是_deco，然后再去执行“func = _func(func)”，而这个func函数名代表的其实就是__deco。 至此，就达到了通过装饰器来传参的目的。给个示例吧： 12345678910111213141516171819202122232425262728293031#让装饰器带参数，#和上一示例相比在外层多了一层包装。#装饰函数名实际上应更有意义些 def deco(deco_type): def _deco(func): def __deco(*args, **kwagrs): print(\"before %s called [%s].\" % (func.__name__, deco_type)) func(*args, **kwagrs) print(\" after %s called [%s].\" % (func.__name__, deco_type)) return __deco return _deco @deco(\"mymodule\")def myfunc(): print(\" myfunc() called.\") @deco(\"module2\")def myfunc2(): print(\" myfunc2() called.\") myfunc()myfunc2() #output:before myfunc called [mymodule]. myfunc() called. after myfunc called [mymodule].before myfunc2 called [module2]. myfunc2() called. after myfunc2 called [module2]. 多重装饰器修饰函数如果说，我上面说的内容都理解了，那么这个东东，就太简单不过了。不就是把我们的是装饰器当中被修饰的函数，对它进行装饰吗？但我在这里还想说的是，我们换个角度看问题。我们的关注点放在原来的被修饰的函数上，就会发现，NB呀，我可以给它添加若干个功能撒。给个示例吧： 1234567891011121314151617181920212223242526def deco(deco_type): def _deco(func): def __deco(*args, **kwagrs): print(\"before %s called [%s].\" % (func.__name__, deco_type)) func(*args, **kwagrs) print(\" after %s called [%s].\" % (func.__name__, deco_type)) return __deco return _deco @deco(\"module1\")@deco(\"mymodule\")def myfunc(): print(\" myfunc() called.\") @deco(\"module2\")def myfunc2(): print(\" myfunc2() called.\") myfunc() #output：before __deco called [module1].before myfunc called [mymodule]. myfunc() called. after myfunc called [mymodule]. after __deco called [module1]. 注意结果哟，@deco(“module1”),来修饰的deco(“mymdule”)的，和我们想的是一样的，完美！ 原文地址","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"【入门】使用hexo快速搭建本地blog","slug":"website/hexo-01","date":"2018-04-06T09:05:52.000Z","updated":"2018-04-24T06:33:02.714Z","comments":true,"path":"website/hexo-01.html","link":"","permalink":"http://yoursite.com/website/hexo-01.html","excerpt":"","text":"国际惯例，先上图 1.安装Git Bash 到这里下载Git Bash，一路回车 安装好后，打开git Bash 输入git version验证是否成功 2.安装node.js 在这里下载(LTS就是Long Term Support，current都可以)，安装过程中记得勾选Add to Path，这样可以自动配置环境变量，，打开Git Bash，输入node -v 3.安装hexo 在你想要存放hexo的位置建立一个文件夹，例如：d:/hexo 在Git Bash中输入cd d:/hexo进入该目录 输入安装hexo的命令 npm i -g hexo 经过一段时间的等待，会出现下面的信息 INFO Start blogging with Hexo!说明安装成功 初始化hexo：hexo init，在你建立的目录会出现一些文件 12345678node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 4.运行hexo 在Git Bash中输入以下命令 123hexo cleanhexo generatehexo server 打开浏览器，输入localhost:4000 tip:其中端口可以指定，hexo server -p 5000 5.Write Blog 可以直接在git中建立文章（具体可参考这里 ），也可以直接使用typora写文章， 这里仅以typora为例： 百度搜索typora，下载安装， 打开你的hexo目录，进入source/_post建立一个txt文件，将后缀更改为md，(如果文件没有后缀，百度搜索windows扩展名)，打开就可以输入你想写的文章了，保存后，直接在Git Bash中输入 1hexo s 就可以看见你的文章了， 如果想引用图片，在source目录下建立一个文件夹，例如img，在文章中插入链接即可，像下面这样 1![](/img/image.jpg) # 注意前面需要加上/ image.jpg为你的图片的全名称 全文完2018年4月6日15:13:50","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"char数组和char指针","slug":"articles/8","date":"2018-04-06T08:19:52.841Z","updated":"2018-04-23T03:20:08.139Z","comments":true,"path":"articles/8.html","link":"","permalink":"http://yoursite.com/articles/8.html","excerpt":"","text":"1、以字符串形式出现的，编译器会在结尾自动添加\\0，思考，为什么？ 存在的C语言方法，如strlen(s)，计算字符串的长度，其中s指针。strlen要计算字符串长度，必须知道哪里是结尾，因此使用\\0表示结尾。只有字符数组才有\\0的概念，其它类型(int)的数组没有这个概念。因为其他类型的数组或者指针，没有strlen这种方法。 那么问题来了，int数组如何计算长度呢？如int a1 = {3,7,9,}; 使用sizeof(a1)/sizeof(int)。 2、数组可以在栈上分配，也可以在堆上分配，但必须指定大小。123 char a1[100]; //在栈上分配 char* pa = new char[100];// 在堆上分配，返回首元素的地址 3、char a1[] = &quot;abc&quot;; 相当于在栈顶分配4个字节，分别放上a，b，c，\\0，等价于char a1 ={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\\0&#39;}; 4、char* pa = &quot;abc&quot;; 分析一下就知道，pa是char指针，”abc”是一个文本字符串，显然类型不吻合，需要适配。可认为编译器做了下面的事情：在常量区分配4个字节，分别放上a，b，c，\\0，然后把a的地址返回给pa。 注意：文本字符串放在常量区，是不可修改的，试图修改，运行异常。那么在思考一下，既然右边是const，而pa并没有限定为const char*，按道理赋值失败。为什么可以成功？ 可以认为在C语言中，到处充斥着这样的代码。为了兼容，必须允许。但是，我们应该写const char* pa =&quot;abc&quot;; 这样的话，试图修改pa的内容，编译报错。 5、char a1[] = &quot;abc&quot;, 等价于char a1[] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\\0&#39;,}; strlen(a1)等于3，长度不包括\\0 假如这样写 char a1[] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,}; strlen(a1)是多少？ 答案不确定，因为strlen一直找到\\0才认为是结尾。6、 char a1[] = &quot;abc&quot;; 下面的结果分别是什么？12cout&lt;&lt;&amp;a1[0]&lt;&lt;endl;cout&lt;&lt;a1&lt;&lt;endl; 输出相同，都是整个数组的内容(note: cout会将从当前地址一直到’\\0&#39;之前的内容输出)。 7、char* pa = &quot;abc&quot;; 下面的结果分别是什么？12345cout&lt;&lt;&amp;pa&lt;&lt;endl;cout&lt;&lt;&amp;pa[0]&lt;&lt;endl;cout&lt;&lt;pa&lt;&lt;endl;cout&lt;&lt;pa[0]&lt;&lt;endl; //输出第一个元素的值cout&lt;&lt;&amp;pa[1]&lt;&lt;endl; //从第下标为1的元素开始，向后输出，直到遇到&apos;\\0&apos;为止 第一行输出pa在栈上的地址，第二行和第三行输出相同，都是整个数组的内容，对于char类型的数组，如果给出某一元素的的地址，那么cout会将从当前地址开始到该数组最后一个元素位置的内容全部输出。pa是指针，就是指向首个元素的地址。 8、char a1[5]; 数组名是个指针常量，不能修改指向。 9、char* pa = &quot;abc&quot;; 可认为pa是个指向常量的指针。 10、下面的结果，违反直觉，按道理第4行，第5行应该输出地址。但是却输出指向的字符串。这有一定的合理性，我们打印char指针，往往是要看指向的内容，而不是要看地址是多少。而且cout很容易做到，只要遇到\\0就结束。那么问题来了，我想看地址怎么办？使用int强制转化为地址。 12345678char a1[]=&quot;abc&quot;;char* pa=&quot;def&quot;;cout&lt;&lt;a1&lt;&lt;endl; //输出abccout&lt;&lt;pa&lt;&lt;endl; //输出defcout&lt;&lt;(int)a1&lt;&lt;endl; // 输出a1地址cout&lt;&lt;(int)pa&lt;&lt;endl; // 输出pa地址 12345678char p[]=&quot;abcde&quot;;char* p2=&quot;abcde&quot;;cout&lt;&lt;sizeof(p)&lt;&lt;endl; //数组大小为6cout&lt;&lt;sizeof(p2)&lt;&lt;endl; // 指针大小为4cout&lt;&lt;strlen(p)&lt;&lt;endl; // 长度为5cout&lt;&lt;strlen(p2)&lt;&lt;endl; // 长度为5 原文地址","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"Sublime text3 快捷键","slug":"articles/10","date":"2018-04-06T08:19:52.833Z","updated":"2018-04-24T06:33:48.757Z","comments":true,"path":"articles/10.html","link":"","permalink":"http://yoursite.com/articles/10.html","excerpt":"","text":"谁在岁月里长长叹息 1.Ctrl+/ 注释选中的内容 2.Ctrl+K,Ctrl+U 将字母转换成大写 3.Ctrl+K,Ctrl+L 将字母转换成小写","categories":[],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}]},{"title":"Hexo,更改文章的永久链接","slug":"articles/15","date":"2018-04-06T08:11:37.000Z","updated":"2018-04-25T09:01:44.515Z","comments":true,"path":"articles/15.html","link":"","permalink":"http://yoursite.com/articles/15.html","excerpt":"","text":"参考教程： https://yq.aliyun.com/articles/8607 https://www.jianshu.com/p/17d55d420d94 更改文章链接样式 默认文章链接是: http://xxx.com/2015/07/06/your-title/ ，如果不想加上日期，直接修改hexo根目录下的_config.yml文件里面的permalink: 1permalink: :title/ 如果你的_posts下面有目录，例如directory那么会显示成http://xxx.com/directory/title","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Python Tkinter 标签和按钮","slug":"articles/4","date":"2017-11-08T02:50:57.000Z","updated":"2018-04-24T06:37:18.011Z","comments":true,"path":"articles/4.html","link":"","permalink":"http://yoursite.com/articles/4.html","excerpt":"","text":"红尘初妆，山河无疆。 最初的面庞，碾碎梦魇无常，命格无双 123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-import tkinter as tkwindow = tk.Tk()window.title('My First Window')window.geometry('320x240') # 设置窗口大小，用英文字母x表示，不要用*# # 创建一个不可变标签# lab = tk.Label(window,text = 'This is Tk',bg = 'gray',font = ('consolas', 12),width = 15, height = 2)# lab.pack() # 固定位置var = tk.StringVar() # 文字变量存储器# 创建一个可变标签# textvariable可以使标签文本变化lab = tk.Label(window,textvariable = var, bg = 'green', font = ('consolas', 12), width = 25, height = 2)lab.pack() # 固定位置on_hit = Falsedef click_me(): global on_hit # 声明全局变量 if on_hit == False: var.set('你点击了按钮') on_hit = True else: var.set('') on_hit = False# 创建一个按钮butt = tk.Button(window,text = 'click me',width = 15, height = 2, command = click_me) # 点击按钮式执行的命令butt.pack()window.mainloop() 完成之后的效果图","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]}